---
layout: post
title: Java并发编程的艺术读后总结（二）
date: 2020-06-29
categories: 技术
tags: 并发编程
---

## Java 并发机制的底层实现原理

Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终需要转化为汇编指令在 CPU 上运行， Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。

### volatile 的应用

volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的”可见性“。

Java 语言规范的第 3 版中对 volatile 的定义：

>  Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

volatile变量在进行写操作时转化成汇编语言会多出一行 **lock 前缀的指令**，这个指令会引起两个步骤

1. **将当前CPU 缓存行（缓存的最小操作单位）的数据写回系统内存**。为了提高处理速度，CPU不直接和内存通信，而是先将系统内存的数据读到内部缓存后再进行操作，操作完后也不知道什么时候写回内存。但现在，**JVM会向CPU发送一条lock前缀的指令，将这个变量所在的缓存行写回到系统内存中**。
2. **这个写回内存的操作会使其他CPU里缓存了当前内存地址的数据无效**。为了保证各个处理器的缓存是一致的，就是实现缓存一致性协议，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，**当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里。**

### synchronized 的实现原理与应用

利用 synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。具体表现形式：

- 对于普通的同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类 Class 对象。
- 对于同步方法快，所示 Synchronized 括号里配置的对象。

### Java 对象头

synchronized的锁是存在 **Java 对象头**里的，Java对象头里的Mark Word里默认存书对象的HashCode、分代年龄和锁标记位，如下图。存储的数据会随锁标志位的变化而变化。 

![markword.png](https://i.loli.net/2020/06/29/YAwX2kbJZ8FPG1E.png)

### 锁的升级与对比

Java SE 1.6 中，锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，这是为了提高获得锁和释放锁的效率。

- 偏向锁

  当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。 如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

  偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，
  持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正
  在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
  如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈
  会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他
  线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

  关闭偏向锁，程序默认进轻量级锁状态。

  ![偏向锁初始化的流程.png](https://i.loli.net/2020/06/29/1EcqtwRheYdaFIp.png)

- 轻量级锁

  线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并
  将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word 。然后线程尝试使用
  CAS将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失
  败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

  轻量级解锁时，会使用原子的CAS操作将 Displaced Mark Word 替换回到对象头，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

  ![争夺锁导致锁膨胀.png](https://i.loli.net/2020/06/29/qNA5Ga4S9noY6Qf.png)

- 锁的优缺点对比

  ![锁的优缺点对比.png](https://i.loli.net/2020/06/29/lfSF5yHxbs7Rreo.png)

### 原子操作的实现原理

原子（atomic）本意是"不能被进一步分割的最小粒子"，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。

- CPU 术语

  ![cpu术语.jpg](https://i.loli.net/2020/06/29/JliEqapoUtT6b8j.jpg)

- 处理器如何实现原子操作

  - **使用总线锁保证原子性**，所谓总线锁就是使用处理器提供一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

  - **使用缓存锁来保证原子性**，“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当太执行锁操作写回到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。**但是有两种情况下处理器不会使用缓存锁定**。

    1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。
    2. 有些处理器不支持缓存锁定。

    > 缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

- Java 如何实现原子操作

  - 使用锁来实现原子操作
    - 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。
  - 使用循环 CAS 实现原子操作，自旋 CAS 实现的基本思路就是循环进行 CAS 操作直到成功为止。
    - CAS 操作的三大问题
      1. **ABA 问题**。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。
      2. **循环时长开销大**。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。
      3. **只能保证一个共享变量的原子操作**。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。

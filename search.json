[{"title":"我的Java面试中碰到的问题","url":"/1999/10/09/2017-6-22-Nginx-demo/","content":"抽象工厂模式（Abstract Factory Pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。如果比较抽象工厂模式和工厂模式，我们不难发现前者只是在工厂模式之上增加了一层抽象的概念。抽象工厂是一个父类工厂，可以创建其它工厂类。所以也可以叫它 “工厂的工厂”。\n单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：\n1. 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。\n2. 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。\n3. 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。\n\n一个简单的单例类：\npublic class Singleton &#123;        /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */      private static Singleton instance = null;            /* 私有构造方法，防止被实例化 */      private Singleton() &#123;      &#125;           /* 静态工程方法，创建实例 */      public static Singleton getInstance() &#123;          if (instance == null) &#123;              instance = new Singleton();          &#125;          return instance;      &#125;           /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */      public Object readResolve() &#123;          return instance;      &#125;  &#125;  \n\n","categories":["技术"],"tags":["Java 面试"]},{"title":"第一篇博客，来自凌晨","url":"/2019/07/18/2019-06-18-log/","content":"第一次写博客，感觉很激动，还有很都不懂的地方，日后慢慢学习吧，加油！！\n","tags":["日常"]},{"title":"北京实训","url":"/2019/07/18/2019-07-18-log/","content":"\n来北京参加千峰的暑假实训，说实话收获不多，本以为这次来是学习一些企业中的应用技能，但是这次老师给我们讲授的内容恰好我学过了，不过俗话说温故知新嘛，也将就的听下来了，但收获并没有来之前，想象中的那么好。\n除了学习之外，我们还抽出了一天的时间旅游了一下，毕竟来一次北京也不容易。去了鸟巢，虽然只能在外边看它的轮廓，也感觉它的设计师有点厉害；旁边的水立方并没有想象中的那么晶莹剔透，感觉像是披了一层薄膜，颜色也就没有那么靓丽了；下一站是天安门，天安门前面emmm真的是可以说是人山人海了，不过仅仅是远观也能感觉到它的威严；下一个目的地是天安门对面的国家博物馆，认真的是太多了。。。我就站在马路对面眺望了一下，没能进去看一眼，说实话有些遗憾。\n单独一段评价下北京的网吧，走了好长时间但是还不到回去的时间，我决定去试一下北京的网吧是怎样的，本打算去网鱼网咖，但北京网鱼网咖的口碑有些不太好,所以就决定从地图上找了一个5星评价的网吧，let’s go，在体验了3个小时之后，我对他的评价差不多可以是5星差评了。为什么这么说，一个标准网咖没有店内订餐、普通座的费用也高达1小时12元，而且店内机器的配置并不高，显卡的性能大概和GTX1050差不多，CPU性能一般，这样的配置大概是勉强能玩PUBG的样子。如果北京本来物价就好价格高也说的过去，如果这些能让我给他3星差评，那么导致我给他5星差评的最主要原因是店内没有吸烟区和无烟区，在北京这个不能在室内吸烟的地方，竟然还存在这样的网吧，我真的是难以忍受，可惜没有6星要不就是6星差评了。\n收获：这些天当然不是什么都没学到。自然也是有所收获：去公司参观我知道了如果参加工作大概是什么样子。后两天也有两位大咖给我们分享个人经历和经验，其中第一位大咖，他说选择很重要，我很喜欢他这个观点，但遗憾的是他并没有明确的说明和个人的经验分享；第二位大咖给我们多的是公司入职的经验、工作的经验和刚入职如何快速适应工作（举例可以从公司内网的wiki中寻找你想要的工作指导，这些往往以往的员工都有所分享)，再就是保持求知欲是重要的、保持求知欲是重要的、保持求知欲是重要的。\n北京之旅虽然略有遗憾，但因为老师和业界大咖们的指导也可以称得上是不虚此行。\n\n","categories":["生活"],"tags":["记录"]},{"title":"关于centos上配置https总结","url":"/2019/08/18/2019-08-18-linux-https/","content":"关于centos上配置https总结购买到免费的证书之后，下载证书（因为我们使用的是Apache所以在下载的时候选择下载适用于Apache的证书）\t\t\t\t\t\t\n确保服务器安装了：openssl和openssl-devel，httpd-devel；没有安装的话用yum安装一下就好了\nyum install openssl  yum install openssl-devel  yum install httpd-devel  # 默认apache是没有安装SSL模块的，所以需要安装  yum install -y mod_ssl #然后去配置Apache的配置文件httpd.conf  LoadModule ssl_module modules/mod_ssl.so  #去掉前面的注释，没有的话就自己加上去加载ssl模块，去modules文件夹下面能找到mod_ssl.so文件，如果没有那就是mod_ssl模块没有安装正确  Include conf.d/httpd-ssl.conf   #去掉注释，`#然后去配置ssl.conf\t\t\t\t\t\t#做完这些记得要开放https的默认端口443端口，然后重启Apache服务器就完成https的配置了  systemctl restart httpd.service\n\n等待1~2分钟就可以用https访问了。\n","categories":["技术"],"tags":["linux"]},{"title":"学习路上程序保存","url":"/2019/08/22/2019-08-22-progame/","content":"Qt入门的第一个小程序\njsp&amp;servlet供销管理系统\n","tags":["程序"]},{"title":"编译原理--day01","url":"/2019/08/26/2019-08-26-Compiling-principle/","content":"我们通常使用的编程语言（例如C）是高级语言（high-level language）：\n\n语义清晰，贴近自然语言（即人类使用的语言），易于理解，编程方便。\n其程序无法被计算机理解和直接执行。\n\n计算机使用机器语言（machine language）：\n\n机器语言程序本质上是一串0，1串，它可以被计算机理解并执行。\n人类理解机器语言比较困难，因而直接使用机器语言编程是困难而效率低下的。\n\n编译器的作用：高级语言只有被转换为机器语言之后才能被机器理解执行。而执行转换这一过程的是编译器。（在此过程中被转换的程序我们称之为源程序，其编译语言通常为高级语言，称为源语言（source language），而转换后的程序称为目标程序，其语言称为目标语言（target language））\n解释程序：使用解释程序，对源程序逐个语句边解释边执行；\n编译程序： 使用翻译程序，将源程序翻译成为低级语言目标程序，然后执行目标程序；\n编译程序和解释程序最主要的区别：是否生成目标程序，运行时的存储分配；\n高级语言程序的处理过程：需要预处理的源程序&amp;#8211;&gt;【预处理程序】&amp;#8211;&gt;源程序&amp;#8211;&gt;【编译程序】&amp;#8211;&gt;目标汇编程序&amp;#8211;&gt;【汇编程序】&amp;#8211;&gt;可在装配的机器代码&amp;#8211;&gt;【装配&#x2F;连接-编译程序&lt;&amp;#8211;可在装配的目标文件】&amp;#8211;&gt;绝对机器代码。\n\n词法分析：\n\n根据语言的词法规则对源程序的字符进行扫描和分解，识别出一个个的单词（单词内部表示形式为二元式 “（class,value）” ）。\n（Class代表单词的类型（大致有5种类：界符（分隔符），保留字，标识符，算符（运算符），常量）。\n\n语法分析：\n\n根据语法规则对单词符号串进行扫描分解，识别出各类语法单位。\n语法单位内部表示为语法树。\n\n语义分析：\n   输入各类语法范畴；根据语言的语义规则，分析其含义，并进行初步翻译；产生中间代码。（中间代码用四元式表示（*,value1,T1,T2），Ti为语义分析程序为存放中间结果而生成的临时变量）.\n\n语义分析：\n   输入各类语法范畴；根据语言的语义规则，分析其含义，并进行初步翻译；产生中间代码。（中间代码用四元式表示（*,value1,T1,T2），Ti为语义分析程序为存放中间结果而生成的临时变量）\n\n优化：\n   输入中间代码；进行等价变换；输出更高效的中间代码。（用以提高目标代码的时、空效率，也就是希望完成同样功能的程序，代码优化后比优化前运行的时间短，占用的存储空间少，有时二者不能同时达到，需根据实际情况取舍）。\n\n目标代码生成：\n\n\n输入优化后的中间代码；变换成特定机器上的低级语言代码，实现最后的翻译；产生目标代码（依赖与机器硬件系统；通常使用汇编语言作为目标程序的实现语言）\n\n&#x2F;表格管理和错误处理：&#x2F;\n\n","tags":["编译原理"]},{"title":"编译原理-Day02","url":"/2019/08/29/2019-08-29-Compiling-principle/","content":"编译程序的结构\n前端和后端的概念源程序–&gt;前端–&gt;中间代码–&gt;后端–&gt;目标代码 （目的：便于移植）前端：完成分析工作（词法分析、语法分析、语义分析）后端：完成综合工作（优化改善目标代码质量、目标代码生成）\n“遍”的概念所谓”遍”，也称作”趟”，是对源程序或其等价的中间语言程序从头到尾扫描并完成规定任务的过程。一个编译过程可由一遍、两遍后多遍完成。一遍可以只完成词法分析工作，一遍也可以完成词法分析和语法分析工作，甚至一遍可以完成整个编译工作；对于多遍的编译程序，第一遍的输入是用户书写的源程序，最后一遍的输出是目标程序，其余是上一边的输出为下一遍的输入。编译程序究竟分为几遍，参考的因素主要是源语言和机器（目标机）的特征一个多遍的编译程序可以比一遍的编译程序少占内存，多遍的编译程序的逻辑结构可能更清晰，但由于遍数多就意味着正价读写中间文件的次数，势必消耗较多的时间，显然会比一遍的编译程序要慢\n编译程序在其他软件的应用\n\n语言的结构化编辑器（提示输入关键字、完成括号匹配等）\n语言程序的调试工具、程序格式化工具（以清晰可读方式打印程序）\n软件测试工具：如FORTRAN，C的静态和动态测试工具（可测试程序语句的覆盖率、路径覆盖率等，都需要编译技术）\n高级程序设计语言的转换工具、程序理解工具（Olink CC++数据流分析 、Eclipse Tptp 性能分析工具）\n网络中的协议\n数据库系统中各种命令语言的翻译。\n\n\t\t\n文法和语言    语言的定义：是由句子组成的集合，是由一组记号所构成的集合。  \n\n语法（Syntax）：表示构成语言句子的各个记号之间的组合规律  \n语义（Semantic）：表示按照各种表示方法所表示的各个记号的特定含义（各个记号和记号所表示的对象之间的关系）  \n语用（Pragmatics）：表示在各个记号所出现的行为中，他们的来源、使用和影响\n一个程序设计语言是一个记号系统，它的完整定义包括语法和语义两个方面所谓一个语言的语法是指一组规律，用它可以形成和产生一个合适的程序；程序设计语言的语义常常分为两类：静态语义和动态语义。静态语义是一系列限定规则，并确定哪些合乎语法的程序是合适的；动态语义也称作运行语义或执行语义，表明程序要做什么，要计算什么。常用的语法描述方法有：正规文法（词法规则）、上下文无关文法（语法规则）。\n使用文法作为工具，不仅是为了严格的定义句子的结构，也是为了用适当的条数的规则把语言的全部句子描述出来，可以说_文法是以有穷集合刻画无穷集合的一个工具。_\n","categories":["技术"],"tags":["编译原理"]},{"title":"Linux常用命令","url":"/2019/08/31/2019-08-31-linux-commands/","content":"转载自：https://www.cnblogs.com/alqscool/p/8397788.html\n\n\n\n查看软件xxx安装内容#dpkg -L xxx\n查找软件#apt-cache search 正则表达式查找文件属于哪个包#dpkg -S filename apt-file search filename\n查询软件xxx依赖哪些包#apt-cache depends xxx\n查询软件xxx被哪些包依赖#apt-cache rdepends xxx\n增加一个光盘源#sudo apt-cdrom add\n系统升级#sudo apt-get update#sudo apt-get upgrade#sudo apt-get dist-upgrade\n清除所以删除包的残余配置文件#dpkg -l ‘grep ^rc’awk ‘{print $2}’ ‘tr [“”n”] [“ “]’sudo xargs dpkg -P -\n编译时缺少h文件的自动处理#sudo auto-apt run .&#x2F;configure\n查看安装软件时下载包的临时存放目录#ls &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives\n备份当前系统安装的所有包的列表#dpkg -get-selections ‘ grep -v deinstall &gt; ~&#x2F;somefile\n从上面备份的安装包的列表文件恢复所有包#dpkg -set-selections &lt; ~&#x2F;somefile sudo dselect\n清理旧版本的软件缓存#sudo apt-get autoclean\n清理所有软件缓存#sudo apt-get clean\n删除系统不再使用的孤立软件#sudo apt-get autoremove\n查看包在服务器上面的地址#apt-get -qq -print-uris install ssh ‘ cut -d”‘ -f2\n系统查看内核#uname -a\n查看Ubuntu版本#cat &#x2F;etc&#x2F;issue\n查看内核加载的模块#lsmod\n查看PCI设备#lspci\n查看USB设备#lsusb\n查看网卡状态#sudo ethtool eth0\n查看CPU信息#cat &#x2F;proc&#x2F;cpuinfo\n显示当前硬件信息#lshw\n硬盘查看硬盘的分区#sudo fdisk -l\n查看IDE硬盘信息#sudo hdparm -i &#x2F;dev&#x2F;hda\n查看STAT硬盘信息**#sudo hdparm -I &#x2F;dev&#x2F;sda或 **#sudo apt-get install blktool#sudo blktool &#x2F;dev&#x2F;sda id\n查看硬盘剩余空间#df -h#df -H\n查看目录占用空间#du -hs 目录名\n优盘没法卸载#sync fuser -km &#x2F;media&#x2F;usbdisk\n内存查看当前的内存使用情况#free -m\n进程查看当前有哪些进程#ps -A\n中止一个进程#kill 进程号(就是ps -A中的第一列的数字) 或者 killall 进程名\n强制中止一个进程(在上面进程中止不成功的时候使用)#kill -9 进程号 或者 killall -9 进程名\n图形方式中止一个程序#xkill 出现骷髅标志的鼠标，点击需要中止的程序即可\n查看当前进程的实时状况#top\n查看进程打开的文件#lsof -p\nADSL 配置 ADSL#sudo pppoeconf\nADSL手工拨号#sudo pon dsl-provider\n激活 ADSL#sudo &#x2F;etc&#x2F;ppp&#x2F;pppoe_on_boot\n断开 ADSL#sudo poff\n查看拨号日志#sudo plog\n如何设置动态域名#首先去http://www.3322.org申请一个动态域名#然后修改 &#x2F;etc&#x2F;ppp&#x2F;ip-up 增加拨号时更新域名指令** sudo vim &#x2F;etc&#x2F;ppp&#x2F;ip-up**#在最后增加如下行 w3m -no-cookie -dump\n网络根据IP查网卡地址#arping IP地址\n查看当前IP地址#ifconfig eth0 ‘awk ‘&#x2F;inet&#x2F; {split($2,x,”:”);print x[2]}’\n查看当前外网的IP地址#w3m -no-cookie -dumpwww.edu.cn&#39;grep-o‘[0-9]”{1,3”}”.[0-9]”{1,3”}”.[0-9]”{1,3”}”.[0-9]”{1,3”}’#w3m -no-cookie -dumpwww.xju.edu.cn&#39;grep-o&#39;[0-9]&quot;{1,3&quot;}&quot;.[0-9]&quot;{1,3&quot;}&quot;.[0-9]&quot;{1,3&quot;}&quot;.[0-9]&quot;{1,3&quot;}&#39; **#w3m -no-cookie -dump ip.loveroot.com’grep -o’[0-9]”{1,3”}”.[0-9]”{1,3”}”.[0-9]”{1,3”}”.[0-9]”{1,3”}’**\n查看当前监听80端口的程序#lsof -i :80\n查看当前网卡的物理地址#arp -a ‘ awk ‘{print $4}’ ifconfig eth0 ‘ head -1 ‘ awk ‘{print $5}’\n立即让网络支持nat#sudo echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward#sudo iptables -t nat -I POSTROUTING -j MASQUERADE\n查看路由信息#netstat -rn sudo route -n\n手工增加删除一条路由#sudo route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1#sudo route del -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1\n修改网卡MAC地址的方法#sudo ifconfig eth0 down 关闭网卡#sudo ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE 然后改地址#sudo ifconfig eth0 up 然后启动网卡\n统计当前IP连接的个数#netstat -na’grep ESTABLISHED’awk ‘{print $5}’’awk -F: ‘{print $1}’’sort’uniq -c’sort -r -n#netstat -na’grep SYN’awk ‘{print $5}’’awk -F: ‘{print $1}’’sort’uniq -c’sort -r -n\n统计当前20000个IP包中大于100个IP包的IP地址#tcpdump -tnn -c 20000 -i eth0 ‘ awk -F “.” ‘{print $1″.”$2″.”$3″.”$4}’ ‘ sort ‘ uniq -c ‘ sort -nr ‘ awk ‘ $1 &gt; 100 ‘\n屏蔽IPV6#echo “blacklist ipv6″ ‘ sudo tee &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-ipv6\n服务添加一个服务#sudo update-rc.d 服务名 defaults 99\n删除一个服务#sudo update-rc.d 服务名 remove\n临时重启一个服务#&#x2F;etc&#x2F;init.d&#x2F;服务名 restart\n临时关闭一个服务#&#x2F;etc&#x2F;init.d&#x2F;服务名 stop\n临时启动一个服务#&#x2F;etc&#x2F;init.d&#x2F;服务名 start\n设置配置默认Java使用哪个#sudo update-alternatives -config java\n修改用户资料#sudo chfn userid\n给apt设置代理#export http_proxy&#x3D;http://xx.xx.xx.xx:xxx\n修改系统登录信息#sudo vim &#x2F;etc&#x2F;motd\n中文转换文件名由GBK为UTF8**#sudo apt-get install convmv convmv -r -f cp936 -t utf8 -notest -nosmart ***\n批量转换src目录下的所有文件内容由GBK到UTF8#find src -type d -exec mkdir -p utf8&#x2F;{} “; find src -type f -exec iconv -f GBK -t UTF-8 {} -o utf8&#x2F;{} “; mv utf8&#x2F; src rm -fr utf8*\n转换文件内容由GBK到UTF8#iconv -f gbk -t utf8 $i &gt; newfile\n转换 mp3 标签编码#sudo apt-get install python-mutagen find . -iname “*.mp3” -execdir mid3iconv -e GBK {} “;\n控制台下显示中文#sudo apt-get install zhcon 使用时，输入zhcon即可\n文件快速查找某个文件#whereis filename#find 目录 -name 文件名\n查看文件类型#file filename\n显示xxx文件倒数6行的内容#tail -n 6 xxx\n让tail不停地读地最新的内容#tail -n 10 -f &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log\n查看文件中间的第五行（含）到第10行（含）的内容#sed -n ‘5,10p’ &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log\n查找包含xxx字符串的文件#grep -l -r xxx .\n全盘搜索文件(桌面可视化)gnome-search-tool\n查找关于xxx的命令#apropos xxx man -k xxx\n通过ssh传输文件#scp -rp &#x2F;path&#x2F;filenameusername@remoteIP:&#x2F;path#将本地文件拷贝到服务器上#scp -rpusername@remoteIP:&#x2F;path&#x2F;filename&#x2F;path#将远程文件从服务器下载到本地\n查看某个文件被哪些应用程序读写#lsof 文件名\n把所有文件的后辍由rm改为rmvb**#rename ‘s&#x2F;.rm$&#x2F;.rmvb&#x2F;‘ ***\n把所有文件名中的大写改为小写**#rename ‘tr&#x2F;A-Z&#x2F;a-z&#x2F;‘ ***\n删除特殊文件名的文件，如文件名：-help.txt#rm - -help.txt 或者 rm .&#x2F;-help.txt\n查看当前目录的子目录**#ls -d &#x2F;. 或 echo &#x2F;.\n将当前目录下最近30天访问过的文件移动到上级back目录#find . -type f -atime -30 -exec mv {} ..&#x2F;back “;\n将当前目录下最近2小时到8小时之内的文件显示出来#find . -mmin +120 -mmin -480 -exec more {} “;\n删除修改时间在30天之前的所有文件#find . -type f -mtime +30 -mtime -3600 -exec rm {} “;\n查找guest用户的以avi或者rm结尾的文件并删除掉#find . -name ‘.avi’ -o -name ‘.rm’ -user ‘guest’ -exec rm {} “;\n查找的不以java和xml结尾,并7天没有使用的文件删除掉**#find . ! -name .java ! -name ‘.xml’ -atime +7 -exec rm {} “;**\n统计当前文件个数#ls &#x2F;usr&#x2F;bin’wc -w\n统计当前目录个数#ls -l &#x2F;usr&#x2F;bin’grep ^d’wc -l\n显示当前目录下2006-01-01的文件名#ls -l ‘grep 2006-01-01 ‘awk ‘{print $8}’\nFTP上传下载文件工具-filezilla**#sudo apt-get install filezilla**\nfilezilla无法列出中文目录？**站点-&gt;字符集-&gt;自定义-&gt;输入：GBK**\n本地中文界面1）下载filezilla中文包到本地目录，如~&#x2F;2）#unrar x Filezilla3_zhCN.rar3) 如果你没有unrar的话，请先安装rar和unrar#sudo apt-get install rar unrar#sudo ln -f &#x2F;usr&#x2F;bin&#x2F;rar &#x2F;usr&#x2F;bin&#x2F;unrar4）先备份原来的语言包,再安装；实际就是拷贝一个语言包。#sudo cp &#x2F;usr&#x2F;share&#x2F;locale&#x2F;zh_CN&#x2F;filezilla.mo &#x2F;usr&#x2F;share&#x2F;locale&#x2F;zh_CN&#x2F;filezilla.mo.bak#sudo cp ~&#x2F;locale&#x2F;zh_CN&#x2F;filezilla.mo &#x2F;usr&#x2F;share&#x2F;locale&#x2F;zh_CN&#x2F;filezilla.mo5）重启filezilla,即可！\n解压缩解压缩 xxx.tar.gz#tar -zxvf xxx.tar.gz\n解压缩 xxx.tar.bz2#tar -jxvf xxx.tar.bz2\n压缩aaa bbb目录为xxx.tar.gz#tar -zcvf xxx.tar.gz aaa bbb\n压缩aaa bbb目录为xxx.tar.bz2#tar -jcvf xxx.tar.bz2 aaa bbb\n解压缩 RAR 文件**1) **先安装#sudo apt-get install rar unrar#sudo ln -f &#x2F;usr&#x2F;bin&#x2F;rar &#x2F;usr&#x2F;bin&#x2F;unrar2) 解压#unrar x aaaa.rar\n解压缩 ZIP 文件**1) **先安装#sudo apt-get install zip unzip#sudo ln -f &#x2F;usr&#x2F;bin&#x2F;zip &#x2F;usr&#x2F;bin&#x2F;unzip2) 解压#unzip x aaaa.zip\nNautilus显示隐藏文件Ctrl+h\n显示地址栏Ctrl+l\n特殊 URI 地址*** computer:&#x2F;&#x2F;&#x2F; - 全部挂载的设备和网络*** network:&#x2F;&#x2F;&#x2F; - 浏览可用的网络*** burn:&#x2F;&#x2F;&#x2F;** - 一个刻录 CDs&#x2F;DVDs 的数据虚拟目录*** smb:&#x2F;&#x2F;&#x2F;** - 可用的 windows&#x2F;samba 网络资源*** x-nautilus-desktop:&#x2F;&#x2F;&#x2F;** - 桌面项目和图标file:&#x2F;&#x2F;&#x2F;- 本地文件*** trash:&#x2F;&#x2F;&#x2F;* - 本地回收站目录*** ftp:&#x2F;&#x2F;** - FTP 文件夹*** ssh:&#x2F;&#x2F; **- SSH 文件夹*** fonts:&#x2F;&#x2F;&#x2F; - 字体文件夹，可将字体文件拖到此处以完成安装*** themes:&#x2F;&#x2F;&#x2F; - 系统主题文件夹\n查看已安装字体在nautilus的地址栏里输入”fonts:&#x2F;&#x2F;&#x2F;“，就可以查看本机所有的fonts\n程序详细显示程序的运行信息#strace -f -F -o outfile\n日期和时间\n设置日期#date -s mm&#x2F;dd&#x2F;yy\n设置时间#date -s HH:MM\n将时间写入CMOS#hwclock -systohc\n读取CMOS时间#hwclock -hctosys\n从服务器上同步时间#sudo ntpdate time.nist.gov#sudo ntpdate time.windows.com\n控制台\n不同控制台间切换Ctrl + ALT + ← Ctrl + ALT + →\n指定控制台切换Ctrl + ALT + Fn(n:1~7)\n控制台下滚屏SHIFT + pageUp&#x2F;pageDown\n控制台抓图#setterm -dump n(n:1~7)\n数据库mysql的数据库存放在地方#&#x2F;var&#x2F;lib&#x2F;mysql\n从mysql中导出和导入数据**#mysqldump 数据库名 &gt; 文件名 **#导出数据库**#mysqladmin create 数据库名 **#建立数据库**#mysql 数据库名 &lt; 文件名 **#导入数据库\n忘了mysql的root口令怎么办#sudo &#x2F;etc&#x2F;init.d&#x2F;mysql stop**#sudo mysqld_safe -skip-grant-tables **#sudo mysqladmin -u user password ‘newpassword”#sudo mysqladmin flush-privileges\n修改mysql的root口令#sudo mysqladmin -uroot -p password ‘你的新密码’\n其它下载网站文档#wget -r -p -np -khttp://www.21cn.com· r：在本机建立服务器端目录结构；· -p: 下载显示HTML文件的所有图片；· -np：只下载目标站点指定目录及其子目录的内容；· -k: 转换非相对链接为相对链接。\n如何删除Totem电影播放机的播放历史记录#rm ~&#x2F;.recently-used\n如何更换gnome程序的快捷键点击菜单，鼠标停留在某条菜单上，键盘输入任意你所需要的键，可以是组合键，会立即生效； 如果要清除该快捷键，请使用backspace\nvim 如何显示彩色字符#sudo cp &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimcurrent&#x2F;vimrc_example.vim &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vimrc\n如何在命令行删除在会话设置的启动程序#cd ~&#x2F;.config&#x2F;autostart rm 需要删除启动程序\n如何提高wine的反应速度#sudo sed -ie ‘&#x2F;GBK&#x2F;,&#x2F;^}&#x2F;d’ &#x2F;usr&#x2F;share&#x2F;X11&#x2F;locale&#x2F;zh_CN.UTF-8&#x2F;XLC_LOCALE\n#chgrp[语法]: chgrp [-R] 文件组 文件…[说明]： 文件的GID表示文件的文件组，文件组可用数字表示， 也可用一个有效的组名表示，此命令改变一个文件的GID，可参看chown。-R 递归地改变所有子目录下所有文件的存取模式[例子]:**＃chgrp group file **将文件 file 的文件组改为 group\n#chmod[语法]: chmod [-R] 模式 文件…或 chmod [ugoa] {+’-‘&#x3D;} [rwxst] 文件…[说明]: 改变文件的存取模式，存取模式可表示为数字或符号串，例如：＃chmod nnnn file ， n为0-7的数字，意义如下:4000 运行时可改变UID2000 运行时可改变GID1000 置粘着位0400 文件主可读0200 文件主可写0100 文件主可执行0040 同组用户可读0020 同组用户可写0010 同组用户可执行0004 其他用户可读0002 其他用户可写0001 其他用户可执行nnnn 就是上列数字相加得到的，例如 chmod 0777 file 是指将文件 file 存取权限置为所有用户可读可写可执行。-R 递归地改变所有子目录下所有文件的存取模式u 文件主g 同组用户o 其他用户a 所有用户\n\n增加后列权限\n\n\n取消后列权限&#x3D; 置成后列权限r 可读w 可写x 可执行s 运行时可置UIDt 运行时可置GID[例子]:\n\n＃chmod 0666 file1 file2 将文件 file1 及 file2 置为所有用户可读可写＃chmod u+x file 对文件 file 增加文件主可执行权限＃chmod o-rwx 对文件file 取消其他用户的所有权限\n#chown[语法]: chown [-R] 文件主 文件…[说明]: 文件的UID表示文件的文件主，文件主可用数字表示， 也可用一个有效的用户名表示，此命令改变一个文件的UID，仅当此文件的文件主或超级用户可使用。-R 递归地改变所有子目录下所有文件的存取模式[例子]:**#chown mary file **将文件 file 的文件主改为 mary#chown 150 file 将文件 file 的UID改为150\nUbuntu命令行下修改网络配置以eth0为例1. 以DHCP方式配置网卡编辑文件&#x2F;etc&#x2F;network&#x2F;interfaces:#sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces并用下面的行来替换有关eth0的行:\nThe primary network interface - use DHCP to find our addressauto eth0iface eth0 inet dhcp用下面的命令使网络设置生效:#sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart当然,也可以在命令行下直接输入下面的命令来获取地址**#sudo dhclient eth0**\n2. 为网卡配置静态IP地址编辑文件&#x2F;etc&#x2F;network&#x2F;interfaces:#sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces并用下面的行来替换有关eth0的行:\nThe primary network interfaceauto eth0iface eth0 inet staticaddress 192.168.3.90gateway 192.168.3.1netmask 255.255.255.0network 192.168.3.0broadcast 192.168.3.255将上面的ip地址等信息换成你自己就可以了.\n用下面的命令使网络设置生效:#sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart\n3. 设定第二个IP地址(虚拟IP地址)编辑文件&#x2F;etc&#x2F;network&#x2F;interfaces:#sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces在该文件中添加如下的行:auto eth0:1iface eth0:1 inet staticaddress 192.168.1.60netmask 255.255.255.0network x.x.x.xbroadcast x.x.x.xgateway x.x.x.x根据你的情况填上所有诸如address,netmask,network,broadcast和gateways等信息.用下面的命令使网络设置生效:#sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart\n4. 设置主机名称(hostname)使用下面的命令来查看当前主机的主机名称:#sudo &#x2F;bin&#x2F;hostname使用下面的命令来设置当前主机的主机名称:#sudo &#x2F;bin&#x2F;hostname newname系统启动时,它会从&#x2F;etc&#x2F;hostname来读取主机的名称.\n5. 配置DNS首先,你可以在&#x2F;etc&#x2F;hosts中加入一些主机名称和这些主机名称对应的IP地址,这是简单使用本机的静态查询.要访问DNS 服务器来进行查询,需要设置&#x2F;etc&#x2F;resolv.conf文件.假设DNS服务器的IP地址是192.168.3.2, 那么&#x2F;etc&#x2F;resolv.conf文件的内容应为:search test.comnameserver 192.168.3.2\n安装AMP服务如果采用Ubuntu Server CD开始安装时，可以选择安装，这系统会自动装上apache2,php5和mysql5。下面主要说明一下如果不是安装的Ubuntu server时的安装方法。用命令在Ubuntu下架设Lamp其实很简单，用一条命令就完成。在终端输入以下命令：#sudo apt-get install apache2 mysql-server php5 php5-mysql php5-gd #phpmyadmin装好后，mysql管理员是root，无密码，通过http://localhost/phpmyadmin就可以访问mysql了\n修改 MySql 密码终端下输入：#mysql -u root#mysql&gt; GRANT ALL PRIVILEGES ON . TO root@localhost IDENTIFIED BY “123456″;‘123456’是root的密码，可以自由设置，但最好是设个安全点的。**#mysql&gt; quit; **退出mysql\napache2的操作命令启动：**#sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 start**重启：**#sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 restart**关闭：**#sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 stop**apache2的默认主目录：&#x2F;var&#x2F;www&#x2F;\n\n\n\n","tags":["linux"]},{"title":"NodeJS","url":"/2019/10/20/2019-10-20-nodejs/","content":"使用 Node.js 搭建服务器const http = require(&#x27;http&#x27;);const hostname = &#x27;127.0.0.1&#x27;; //miss, hostname is not definedconst port = 8081;const server = http.createServer((req, res) =&gt; &#123;  res.statusCode = 200;  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);  res.end(&#x27;Hello World&#x27;);&#125;);server.listen(port, hostname, () =&gt; &#123;  console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);\n\n","categories":["技术"],"tags":["NodeJS"]},{"title":"Maven 执行 package,install,deploy时使用clean和不使用的区别","url":"/2020/10/12/2020-10-12-mvn-clean/","content":"Maven 执行 package,install,deploy时使用clean和不使用的区别被别人问道 Maven install 之前 clean 有什么用，能不能不 clean ? 才发现自己平时都是无脑操作。。然后就去实验了一下，发现有的时候用 mvn install后，新改的内容不生效，要先 mvn clean 之后才会生效。这才有了今天这个总结。\n总结\n\n理论上来讲不做mvn clean 得到的jar包应该是最新的，除非其他方式修改jar包中的内容而不修改源代码。\\2. 平时可以用mvn install，而不进行chean节省时间（如果你觉得节省时间多的话），但最保险还是用 mvn clean install 生成最新的jar包或其他包\\3. 不想用mvn clean又想保证jar包最新，建议添加 -Djar.forceCreation 参数\n\n","categories":["技术"],"tags":["Maven"]},{"title":"密码恢复 Hashcat","url":"/2020/10/19/2020-10-20-World's-fastest-and-most-advanced-password-recovery-utility/","content":"World’s fastest and most advanced password recovery utilityhashcat是世界上最快，最先进的密码恢复实用程序，为300多种高度优化的哈希算法提供了五种独特的攻击模式。hashcat当前在Linux，Windows和macOS上支持CPU，GPU和其他硬件加速器，并具有帮助启用分布式密码破解的功能。\n获取方式：https://github.com/hashcat/hashcat\n使用方式：\nUsage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...- [ Options ] - Options Short / Long           | Type | Description                                          | Example================================+======+======================================================+======================= -m, --hash-type                | Num  | Hash-type, see references below                      | -m 1000 -a, --attack-mode              | Num  | Attack-mode, see references below                    | -a 3 -V, --version                  |      | Print version                                        | -h, --help                     |      | Print help                                           |     --quiet                    |      | Suppress output                                      |     --hex-charset              |      | Assume charset is given in hex                       |     --hex-salt                 |      | Assume salt is given in hex                          |     --hex-wordlist             |      | Assume words in wordlist are given in hex            |     --force                    |      | Ignore warnings                                      |     --status                   |      | Enable automatic update of the status screen         |     --status-json              |      | Enable JSON format for status ouput                  |     --status-timer             | Num  | Sets seconds between status screen updates to X      | --status-timer=1     --stdin-timeout-abort      | Num  | Abort if there is no input from stdin for X seconds  | --stdin-timeout-abort=300     --machine-readable         |      | Display the status view in a machine-readable format |     --keep-guessing            |      | Keep guessing the hash after it has been cracked     |     --self-test-disable        |      | Disable self-test functionality on startup           |     --loopback                 |      | Add new plains to induct directory                   |     --markov-hcstat2           | File | Specify hcstat2 file to use                          | --markov-hcstat2=my.hcstat2     --markov-disable           |      | Disables markov-chains, emulates classic brute-force |     --markov-classic           |      | Enables classic markov-chains, no per-position       | -t, --markov-threshold         | Num  | Threshold X when to stop accepting new markov-chains | -t 50     --runtime                  | Num  | Abort session after X seconds of runtime             | --runtime=10     --session                  | Str  | Define specific session name                         | --session=mysession     --restore                  |      | Restore session from --session                       |     --restore-disable          |      | Do not write restore file                            |     --restore-file-path        | File | Specific path to restore file                        | --restore-file-path=x.restore -o, --outfile                  | File | Define outfile for recovered hash                    | -o outfile.txt     --outfile-format           | Str  | Outfile format to use, separated with commas         | --outfile-format=1,3     --outfile-autohex-disable  |      | Disable the use of $HEX[] in output plains           |     --outfile-check-timer      | Num  | Sets seconds between outfile checks to X             | --outfile-check=30     --wordlist-autohex-disable |      | Disable the conversion of $HEX[] from the wordlist   | -p, --separator                | Char | Separator char for hashlists and outfile             | -p :     --stdout                   |      | Do not crack a hash, instead print candidates only   |     --show                     |      | Compare hashlist with potfile; show cracked hashes   |     --left                     |      | Compare hashlist with potfile; show uncracked hashes |     --username                 |      | Enable ignoring of usernames in hashfile             |     --remove                   |      | Enable removal of hashes once they are cracked       |     --remove-timer             | Num  | Update input hash file each X seconds                | --remove-timer=30     --potfile-disable          |      | Do not write potfile                                 |     --potfile-path             | File | Specific path to potfile                             | --potfile-path=my.pot     --encoding-from            | Code | Force internal wordlist encoding from X              | --encoding-from=iso-8859-15     --encoding-to              | Code | Force internal wordlist encoding to X                | --encoding-to=utf-32le     --debug-mode               | Num  | Defines the debug mode (hybrid only by using rules)  | --debug-mode=4     --debug-file               | File | Output file for debugging rules                      | --debug-file=good.log     --induction-dir            | Dir  | Specify the induction directory to use for loopback  | --induction=inducts     --outfile-check-dir        | Dir  | Specify the outfile directory to monitor for plains  | --outfile-check-dir=x     --logfile-disable          |      | Disable the logfile                                  |     --hccapx-message-pair      | Num  | Load only message pairs from hccapx matching X       | --hccapx-message-pair=2     --nonce-error-corrections  | Num  | The BF size range to replace AP&#x27;s nonce last bytes   | --nonce-error-corrections=16     --keyboard-layout-mapping  | File | Keyboard layout mapping table for special hash-modes | --keyb=german.hckmap     --truecrypt-keyfiles       | File | Keyfiles to use, separated with commas               | --truecrypt-keyf=x.png     --veracrypt-keyfiles       | File | Keyfiles to use, separated with commas               | --veracrypt-keyf=x.txt     --veracrypt-pim-start      | Num  | VeraCrypt personal iterations multiplier start       | --veracrypt-pim-start=450     --veracrypt-pim-stop       | Num  | VeraCrypt personal iterations multiplier stop        | --veracrypt-pim-stop=500 -b, --benchmark                |      | Run benchmark of selected hash-modes                 |     --benchmark-all            |      | Run benchmark of all hash-modes (requires -b)        |     --speed-only               |      | Return expected speed of the attack, then quit       |     --progress-only            |      | Return ideal progress step size and time to process  | -c, --segment-size             | Num  | Sets size in MB to cache from the wordfile to X      | -c 32     --bitmap-min               | Num  | Sets minimum bits allowed for bitmaps to X           | --bitmap-min=24     --bitmap-max               | Num  | Sets maximum bits allowed for bitmaps to X           | --bitmap-max=24     --cpu-affinity             | Str  | Locks to CPU devices, separated with commas          | --cpu-affinity=1,2,3     --hook-threads             | Num  | Sets number of threads for a hook (per compute unit) | --hook-threads=8     --example-hashes           |      | Show an example hash for each hash-mode              |     --backend-ignore-cuda      |      | Do not try to open CUDA interface on startup         |     --backend-ignore-opencl    |      | Do not try to open OpenCL interface on startup       | -I, --backend-info             |      | Show info about detected backend API devices         | -I -d, --backend-devices          | Str  | Backend devices to use, separated with commas        | -d 1 -D, --opencl-device-types      | Str  | OpenCL device-types to use, separated with commas    | -D 1 -O, --optimized-kernel-enable  |      | Enable optimized kernels (limits password length)    | -w, --workload-profile         | Num  | Enable a specific workload profile, see pool below   | -w 3 -n, --kernel-accel             | Num  | Manual workload tuning, set outerloop step size to X | -n 64 -u, --kernel-loops             | Num  | Manual workload tuning, set innerloop step size to X | -u 256 -T, --kernel-threads           | Num  | Manual workload tuning, set thread count to X        | -T 64     --backend-vector-width     | Num  | Manually override backend vector-width to X          | --backend-vector=4     --spin-damp                | Num  | Use CPU for device synchronization, in percent       | --spin-damp=10     --hwmon-disable            |      | Disable temperature and fanspeed reads and triggers  |     --hwmon-temp-abort         | Num  | Abort if temperature reaches X degrees Celsius       | --hwmon-temp-abort=100     --scrypt-tmto              | Num  | Manually override TMTO value for scrypt to X         | --scrypt-tmto=3 -s, --skip                     | Num  | Skip X words from the start                          | -s 1000000 -l, --limit                    | Num  | Limit X words from the start + skipped words         | -l 1000000     --keyspace                 |      | Show keyspace base:mod values and quit               | -j, --rule-left                | Rule | Single rule applied to each word from left wordlist  | -j &#x27;c&#x27; -k, --rule-right               | Rule | Single rule applied to each word from right wordlist | -k &#x27;^-&#x27; -r, --rules-file               | File | Multiple rules applied to each word from wordlists   | -r rules/best64.rule -g, --generate-rules           | Num  | Generate X random rules                              | -g 10000     --generate-rules-func-min  | Num  | Force min X functions per rule                       |     --generate-rules-func-max  | Num  | Force max X functions per rule                       |     --generate-rules-seed      | Num  | Force RNG seed set to X                              | -1, --custom-charset1          | CS   | User-defined charset ?1                              | -1 ?l?d?u -2, --custom-charset2          | CS   | User-defined charset ?2                              | -2 ?l?d?s -3, --custom-charset3          | CS   | User-defined charset ?3                              | -4, --custom-charset4          | CS   | User-defined charset ?4                              | -i, --increment                |      | Enable mask increment mode                           |     --increment-min            | Num  | Start mask incrementing at X                         | --increment-min=4     --increment-max            | Num  | Stop mask incrementing at X                          | --increment-max=8 -S, --slow-candidates          |      | Enable slower (but advanced) candidate generators    |     --brain-server             |      | Enable brain server                                  |     --brain-server-timer       | Num  | Update the brain server dump each X seconds (min:60) | --brain-server-timer=300 -z, --brain-client             |      | Enable brain client, activates -S                    |     --brain-client-features    | Num  | Define brain client features, see below              | --brain-client-features=3     --brain-host               | Str  | Brain server host (IP or domain)                     | --brain-host=127.0.0.1     --brain-port               | Port | Brain server port                                    | --brain-port=13743     --brain-password           | Str  | Brain server authentication password                 | --brain-password=bZfhCvGUSjRq     --brain-session            | Hex  | Overrides automatically calculated brain session     | --brain-session=0x2ae611db     --brain-session-whitelist  | Hex  | Allow given sessions only, separated with commas     | --brain-session-whitelist=0x2ae611db\n\n常用的 options\n-m  &#x2F;&#x2F;指定hash-type，例如 winZip 是 13600，详细可参考 https://hashcat.net/wiki/doku.php?id=example_hashes\n\n-a  &#x2F;&#x2F;指定attack-model  0：Straight，1：Combination，3：Brute-force，6：Hybrid Wordlist + Mask，7：Hybrid Mask + Wordlist\n\n–increment  –increment-min –increment-max &#x2F;&#x2F;配置密码的最小长度和最大长度\n\n-D 要使用的OpenCL设备类型, 1:CPU, 2:GPU,3 FPGA, DSP, Co-Processor\n\n-w  启用特定的工作负载配置文件，请参见下面的池\n\n[ Workload Profiles ]\n\n  # | Performance | Runtime | Power Consumption | Desktop Impact\n ===+=============+=========+===================+=================\n  1 | Low         |   2 ms  | Low               | Minimal\n  2 | Default     |  12 ms  | Economic          | Noticeable\n  3 | High        |  96 ms  | High              | Unresponsive\n  4 | Nightmare   | 480 ms  | Insane            | Headless\n\n\n\n\n\n\n获取加密文件的 hash 通过 john the ripper\n\n","categories":["杂项"],"tags":["tools"]},{"title":"面试中被问到的问题","url":"/2020/10/20/2020-10-20-question-during-the-interview/","content":"sleep() 方法和 wait() 方法区别和共同点?\n两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。\n两者都可以暂停线程的执行。\nWait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。\nwait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 **wait(long timeout)**超时后线程会自动苏醒。\n\nConcurrentHashMapVersion 1.7ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。\nConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。\nVersion 1.8\nJava8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 &#x2F; 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。利用CAS+Synchronized来保证并发更新的安全。\n","categories":["技术"],"tags":["Interview"]},{"title":"Vue 踩坑","url":"/2020/10/29/2020-10-29-Vue-template/","content":"又要写一学期一度的大作业，这次试试用下 Vue， 下面是踩坑集锦 (— —!).\nComponent template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.第一次写 template 试了一下 ElementUI 的一个样例，直接粘贴到 template 内报错了\n&lt;template&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;\n\n基础不牢的菜鸟翻了好一会儿文档才找到，原来 Vue 模板只能有一个跟对象。\n所以你想要出现正常的效果，你的用一个div来或是别的标签来包裹全部的元素。\n正确的写法就是：\n&lt;template&gt;\t&lt;div&gt;\t\t&lt;el-row&gt;\t\t  &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t&lt;/el-row&gt;\t\t&lt;el-row&gt;\t\t  &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t&lt;/el-row&gt;\t\t&lt;el-row&gt;\t\t  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t&lt;/el-row&gt;\t\t&lt;el-row&gt;\t\t  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t&lt;/el-row&gt;\t\t&lt;el-row&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t  &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt;\t\t&lt;/el-row&gt;\t&lt;/div&gt;&lt;/template&gt;\n\n配置路径别名// vue.config.jsmodule.exports = &#123;  &quot;transpileDependencies&quot;: [    &quot;vuetify&quot;  ]    &#125;\n\n","categories":["技术"],"tags":["Vue"]},{"title":"mybatis-generator 基本配置","url":"/2020/12/04/2020-12-4-mybatis-generator/","content":"pom.xml\n&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;\t\t\t\t&lt;version&gt;1.4.0&lt;/version&gt;\t\t\t\t&lt;configuration&gt;\t\t\t\t\t&lt;configurationFile&gt;src/main/resources/generator/generator.xml&lt;/configurationFile&gt;\t\t\t\t\t&lt;overwrite&gt;true&lt;/overwrite&gt;\t\t\t\t\t&lt;verbose&gt;true&lt;/verbose&gt;\t\t\t\t&lt;/configuration&gt;\t\t\t\t&lt;dependencies&gt;\t\t\t\t\t&lt;dependency&gt;\t\t\t\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t\t\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t\t\t\t\t&lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;\t\t\t\t\t&lt;/dependency&gt;\t\t\t\t&lt;/dependencies&gt;\t\t\t&lt;/plugin&gt;\n\n\n\ngenerator.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt;    &lt;!-- &lt;classPathEntry  location=&quot;G:\\Program Files\\java\\apache-maven-3.6.1\\repository\\mysql\\mysql-connector-java\\8.0.13\\mysql-connector-java-8.0.13.jar&quot;/&gt; --&gt;    &lt;context id=&quot;DB2Tables&quot;  targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库链接URL，用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=GMT%2B8&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;        &lt;/jdbcConnection&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- 生成模型的包名和位置--&gt;        &lt;javaModelGenerator targetPackage=&quot;com.example.demo.entity&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 生成映射文件的包名和位置--&gt;        &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 生成DAO的包名和位置--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.example.demo.mapper&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;        &lt;table tableName=&quot;user&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n","categories":["技术"],"tags":["mybatis"]},{"title":"第30题：串联所有单词的子串","url":"/2020/03/02/2020-3-2-leetcode-30/","content":"解法一首先，最直接的思路，判断每个子串是否符合，符合就把下标保存起来，最后返回即可。\n如上图，利用循环变量 i ，依次后移，判断每个子串是否符合即可。\n怎么判断子串是否符合？这也是这个题的难点了，由于子串包含的单词顺序并不需要固定，如果是两个单词 A，B，我们只需要判断子串是否是 AB 或者 BA 即可。如果是三个单词 A，B，C 也还好，只需要判断子串是否是 ABC，或者 ACB，BAC，BCA，CAB，CBA 就可以了，但如果更多单词呢？那就崩溃了。\n用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。看下具体的例子。\n看下图，我们把 words 存到一个 HashMap 中。\n\n然后遍历子串的每个单词。\n\n第一个单词在 HashMap1 中，然后我们把 foo 存到 HashMap2 中。并且比较此时 foo 的 value 和 HashMap1 中 foo 的 value，1 &lt; 2，所以我们继续扫描。\n\n第二个单词也在 HashMap1 中，然后把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 2 ，然后继续比较此时 foo 的 value 和 HashMap1 中 foo 的 value，2 &lt;&#x3D; 2，所以继续扫描下一个单词。\n\n第三个单词也在 HashMap1 中，然后把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 3，然后继续比较此时 foo 的 value 和 HashMap1 中 foo 的 value，3 &gt; 2，所以表明该字符串不符合。然后判断下个子串就好了。\n当然上边的情况都是单词在 HashMap1 中，如果不在的话就更好说了，不在就表明当前子串肯定不符合了，直接判断下个子串就好了。\n看一下代码吧\npublic List&lt;Integer&gt; findSubstring(String s, String[] words) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();    int wordNum = words.length;    if (wordNum == 0) &#123;        return res;    &#125;    int wordLen = words[0].length();    //HashMap1 存所有单词    HashMap&lt;String, Integer&gt; allWords = new HashMap&lt;String, Integer&gt;();    for (String w : words) &#123;        int value = allWords.getOrDefault(w, 0);        allWords.put(w, value + 1);    &#125;    //遍历所有子串    for (int i = 0; i &lt; s.length() - wordNum * wordLen + 1; i++) &#123;        //HashMap2 存当前扫描的字符串含有的单词        HashMap&lt;String, Integer&gt; hasWords = new HashMap&lt;String, Integer&gt;();        int num = 0;        //判断该子串是否符合        while (num &lt; wordNum) &#123;            String word = s.substring(i + num * wordLen, i + (num + 1) * wordLen);            //判断该单词在 HashMap1 中            if (allWords.containsKey(word)) &#123;                int value = hasWords.getOrDefault(word, 0);                hasWords.put(word, value + 1);                //判断当前单词的 value 和 HashMap1 中该单词的 value                if (hasWords.get(word) &gt; allWords.get(word)) &#123;                    break;                &#125;            &#125; else &#123;                break;            &#125;            num++;        &#125;        //判断是不是所有的单词都符合条件        if (num == wordNum) &#123;            res.add(i);        &#125;    &#125;    return res;&#125;\n\n时间复杂度：假设 s 的长度是 n，words 里有 m 个单词，那么时间复杂度就是 O（n * m）。\n空间复杂度：两个 HashMap，假设 words 里有 m 个单词，就是 O（m）。\n解法二我们在解法一中，每次移动一个字符。\n\n现在为了方便讨论，我们每次移动一个单词的长度，也就是 3 个字符，这样所有的移动被分成了三类。\n\n\n\n以上三类我们以第一类从 0 开始移动为例，讲一下如何对算法进行优化，有三种需要优化的情况。\n\n情况一：当子串完全匹配，移动到下一个子串的时候。\n\n\n在解法一中，对于 i &#x3D; 3 的子串，我们肯定是从第一个 foo 开始判断。但其实前两个 foo 都不用判断了 ，因为在判断上一个 i &#x3D; 0 的子串的时候我们已经判断过了。所以解法一中的 HashMap2 每次并不需要清空从 0 开始，而是可以只移除之前 i &#x3D; 0 子串的第一个单词 bar 即可，然后直接从箭头所指的 foo 开始就可以了。\n\n情况二：当判断过程中，出现不符合的单词。\n\n\n但判断 i &#x3D; 0 的子串的时候，出现了 the ，并不在所给的单词中。所以此时 i &#x3D; 3，i &#x3D; 6 的子串，我们其实并不需要判断了。我们直接判断 i &#x3D; 9 的情况就可以了。\n\n情况三：判断过程中，出现的是符合的单词，但是次数超了。\n\n\n对于 i &#x3D; 0 的子串，此时判断的 bar 其实是在 words 中的，但是之前已经出现了一次 bar，所以 i &#x3D; 0 的子串是不符合要求的。此时我们只需要往后移动窗口，i &#x3D; 3 的子串将 foo 移除，此时子串中一定还是有两个 bar，所以该子串也一定不符合。接着往后移动，当之前的 bar 被移除后，此时 i &#x3D; 6 的子串，就可以接着按正常的方法判断了。\n所以对于出现 i &#x3D; 0 的子串的情况，我们可以直接从 HashMap2 中依次移除单词，当移除了之前次数超的单词的时候，我们就可以正常判断了，直接从移除了超出了次数的单词后，也就是 i &#x3D; 6 开始判断就可以了。\n看一下代码吧。\npublic List&lt;Integer&gt; findSubstring(String s, String[] words) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();    int wordNum = words.length;    if (wordNum == 0) &#123;        return res;    &#125;    int wordLen = words[0].length();    HashMap&lt;String, Integer&gt; allWords = new HashMap&lt;String, Integer&gt;();    for (String w : words) &#123;        int value = allWords.getOrDefault(w, 0);        allWords.put(w, value + 1);    &#125;    //将所有移动分成 wordLen 类情况    for (int j = 0; j &lt; wordLen; j++) &#123;        HashMap&lt;String, Integer&gt; hasWords = new HashMap&lt;String, Integer&gt;();        int num = 0; //记录当前 HashMap2（这里的 hasWords 变量）中有多少个单词\t\t//每次移动一个单词长度        for (int i = j; i &lt; s.length() - wordNum * wordLen + 1; i = i + wordLen) &#123;            boolean hasRemoved = false; //防止情况三移除后，情况一继续移除            while (num &lt; wordNum) &#123;                String word = s.substring(i + num * wordLen, i + (num + 1) * wordLen);                if (allWords.containsKey(word)) &#123;                    int value = hasWords.getOrDefault(word, 0);                    hasWords.put(word, value + 1);                    //出现情况三，遇到了符合的单词，但是次数超了                    if (hasWords.get(word) &gt; allWords.get(word)) &#123;                        // hasWords.put(word, value);                        hasRemoved = true;                        int removeNum = 0;                        //一直移除单词，直到次数符合了                        while (hasWords.get(word) &gt; allWords.get(word)) &#123;                            String firstWord = s.substring(i + removeNum * wordLen, i + (removeNum + 1) * wordLen);                            int v = hasWords.get(firstWord);                            hasWords.put(firstWord, v - 1);                            removeNum++;                        &#125;                        num = num - removeNum + 1; //加 1 是因为我们把当前单词加入到了 HashMap 2 中                        i = i + (removeNum - 1) * wordLen; //这里依旧是考虑到了最外层的 for 循环，看情况二的解释                        break;                    &#125;                //出现情况二，遇到了不匹配的单词，直接将 i 移动到该单词的后边（但其实这里                //只是移动到了出现问题单词的地方，因为最外层有 for 循环， i 还会移动一个单词                //然后刚好就移动到了单词后边）                &#125; else &#123;                    hasWords.clear();                    i = i + num * wordLen;                    num = 0;                    break;                &#125;                num++;            &#125;            if (num == wordNum) &#123;                res.add(i);            &#125;            //出现情况一，子串完全匹配，我们将上一个子串的第一个单词从 HashMap2 中移除            if (num &gt; 0 &amp;&amp; !hasRemoved) &#123;                String firstWord = s.substring(i, i + wordLen);                int v = hasWords.get(firstWord);                hasWords.put(firstWord, v - 1);                num = num - 1;            &#125;        &#125;    &#125;    return res;&#125;\n\n时间复杂度：算法中外层的两个for 循环的次数肯定是所有的子串，假设是 n。考虑一下，最极端的情况，每个子串的判断都进了 while 循环，wordNum 等于 m。对于解法一，因为每次都是从头判断，所以 while 循环循环了 m 次。但这里我们由于没有清空，所以每次只判断新加入的单词就可以了，只需判断一次，所以时间复杂度是 O（n）。\n或者换一种理解方式，判断子串是否符合，本质上也就是判断每个单词符不符合，假设 s 的长度是 n，那么就会大约有 n 个子串，也就是会有 n 个单词。而对于每个单词，我们只有刚开始判断符不符合的时候访问一次，还有就是把它移除的时候访问一次，所以每个单词最多访问 2 次，所以时间复杂度是 O（n）。\n空间复杂度：没有变化，依旧是两个 HashMap, 假设 words 里有 m 个单词，就是 O（m）。\n\n作者：windliang链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["技术"],"tags":["LeetCode"]},{"title":"第一次接触gitee pages 和 jekyll","url":"/2020/06/22/2020-6-22-first-experience-jekyll/","content":"初次体验 Gitee Pages 服务和 Jekyll使用 Gitee Pages 之前我写博客主要还是通过购买服务器然后搭建一个博客，大量的配置和经常的软件更新让我耗费了不少精力和时间在上面。\n这时候我找到了 Gitee Pages 和 Jekyll，她的好处在于我终于可以不用再为软件更新、服务器安全和种种配置而困扰了，最最重要的是文章可以用 Markdown 编写。这么好用的东西，i了i了。\n\n 今天的你比昨天强，那么也就证明你进步了；只要你离自己的目标进了，就说明你成功了。\n\n","categories":["生活"],"tags":["gitee jekyll"]},{"title":"Redis 数据类型(一)","url":"/2020/06/22/2020-6-22-redis-data-type/","content":"Redis 数据类型(一)Redis 不仅仅是简单的 key-value 存储器，同时也是一种 data structures server。传统的 key-value 是指支持使用一个 key 字符串来索引 value 字符串的存储，而 Redis 中，value 不仅仅支持字符串，还支持更多的复杂结构，包括列表、集合、哈希表等。\n字符串类型字符串时一种最基本、最常用的 Redis 值类型。\n在 Redis 中我们可以使用 set 和 get 命令来创建和检索 strings。\n&gt; set mykey somevalue #设置一个 key 叫 mykey 他的值为 somevalue&gt; get mykey\t#取得 mykey 的值\n\n使用 set 和 get 命令来创建和检索 strings。注意：set 命令将取代现有的任何已经存在的 key。set 命令还有一个提供附加参数的选项，我们能够让 set 命令只有在没有相同 key 的情况下成功，反之亦然，可以让 set 命令在有相同 key 值的情况下成功：\n&gt; set mykey newval nx #没有相同的 key 时成功&gt; set mykey newval xx #有相同的 key 时成功\n\n有趣的是，在 Redis 中当我们把数字作为 string 值得时候，incr 命令会让 value 值成为一个整数，每运行一次这个数字 +1，而且还有命令 incrby 则是一个加法运算。类似的命令还有：decr 和 decrby，它们分别是递减和减法。\n&gt; set counter 100 # 初始化&gt; incr counter   # +1&gt; incr counter   # +1&gt; incrby counter 50 # +50 自定义计数\n\n\n小技巧 Redis 中可以使用命令 mset 和 mget 命令一次性完成多个 key-value 的对应关系，使用 mget 命令， Redis 返回一个 value 的数组。\n\nList 类型Redis 列表是简单的字符串列表，按照插入顺序插入。你可以添加一个元素到列表的头部（左边）或者尾部（右边），lpush 命令插入一个新的元素到头部，而 rpush 命令插入一个新元素到尾部。当这两个操作中的任一操作在一个空的 Key 上执行时就会创建一个新的列表。相似的，如果一个列表操作清空一个列表，那么对应的 key 将被从 key 空间删除。\n&gt; rpush mylist A\t\t# A&gt; rpush mylist B\t\t# A B&gt; lpush mylist first\t# first A B&gt; lrange mylist 0 -1\t# 列出列表中的指定元素\n\n\nlrange 需要两个索引，0 表示 list 开头第一个，-1 表示 list 的倒数第一个，即最后一个。-2 则是 list 的倒数第二个，以此类推。\n\n这些命令你也可以这样写，可以同时放入多个元素到 list 中\n&gt; rpush mylist 1 2 3 4 5 &quot;foo bar&quot;&gt; lrange mylist 0 -1\n\n在 Redis 的命令操作中，还有一类重要的操作 pop，它可以弹出一个元素，简单的理解就是获取并删除第一个元素，和 push 类似的是它也支持双边的操作，可以从右边弹出一个元素也可以从左边弹出一个元素，对应的指令为 rpop 和 lpop：\n&gt; rpush mylist a b c\t#在 mylist 右边插入 c b a&gt; rpop mylist\t\t\t#从 mylist 右边弹出一个&gt; lrange mylist 0 -1\t#此时 mylist 应有 b a&gt; lpop mylist\t\t\t#从 mylist 左边弹出一个&gt; lrange mylist 0 -1\t#此时 mylist 应有 b\n\n\n一个列表最多可以包含 4294967295（2 的 32 次方减一）个元素，这意味着它可以容纳海量的信息，最终瓶颈一般都取决于服务器内存大小。\n\nList 的阻塞\n关于 “阻塞“ 操作，打个比方：\n假如你要去楼下买一个汉堡，一个汉堡需要花一定的时间才能做出来，非阻塞式的做法是去付完钱走人，过一段时间来看一下汉堡是否做好了，没好就先离开，过一会儿再来，而且要知道可能不止你一个人在买汉堡，在你离开的时候很可能别人会取走你的汉堡，这是很让人烦的事情。\n阻塞式就不一样了，付完钱一直在那儿等着，不拿到汉堡不走人，并且后面来的人统统排队。\nRedis 提供了阻塞式访问 brpop 和 blpop 命令。用户可以在获取数据不存在时阻塞请求队列，如果在一定的时间内获取到了数据那么就返回这个数据，如果超时之后还是没有这个数据那么就返回nil。\nHash 类型Redis Hashes 是一个 string 类型的 field 和 value 的映射表，Hashes 特别适合用于存储对象。例如一个有名、姓、年龄等等属性的用户：一个带有一些字段的 hash 仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的 Redis 实例中。哈希主要用来表现对象，它们有能力存储很多对象，因此你可以将哈希用于许多其它的任务。\n&gt; hmset user:1000 username antirez birthyear 1977 verified 1 #hmset 同时添加多个&gt; hget user:1000 username #取得 user：1000 中的 username 的值&gt; hget user:1000 birthyear&gt; hgetall user:1000\t#取得 user:1000 中的所有的键和值\n\nhmset 命令设置一个多域的 hash 表，hget 命令获取指定的单域，hgetall 命令获取指定 key 的所有信息。hmget 类似于 hget，只是返回一个 value 数组。\n&gt; hmget user:1000 username birthyear no-such-field\n\n同样可以根据需要对 hash 表的表项进行单独的操作，例如 hincrby 等等。\n","categories":["技术"],"tags":["Redis"]},{"title":"Redis 高级应用","url":"/2020/06/23/2020-6-23-redis-advaced-tips/","content":"Redis 高级应用这里我将简单介绍 Redis 的高级应用，包括：安全性，事务处理，持久化机制的使用。\n安全性涉及到客户端连接是需要指定密码的（由于 redis 速度相当的快，一秒钟大约可以 150K 次的密码尝试，所以建议设置一个强度很大的密码）。\n设置密码的方式有两种：\n\n使用 config set 命令的 requirepass 参数，具体格式为 config set requirepass [password]&quot;。\n在 Redis 的安装目录中的 redis.conf 文件中设置 requirepass 属性，后面为密码。\n\n输入认证的方式也有两种：\n\n登录时可以使用 redis-cli -a password。\n登录后可以使用 auth password。\n\n事务处理Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 multi 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 exec 命令时，redis 会顺序的执行队列中的所有命令。\n&gt; multi\t\t\t#开启事务队列&gt; set name a&gt; set name b&gt; exec\t\t\t#执行事务\n\n\n注意：Redis 对于事务的处理方式比较特殊，它不会在事务过程中出错时恢复到之前的状态，这在实际应用中导致我们不能依赖 Redis 的事务来保证数据一致性。\n\n持久化机制内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。\nRedis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。\nRedis 支持两种持久化方式：\n\nsnapshotting（快照）：将数据存放到文件里，默认方式。 是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如： save 900 1：900 秒内如果超过 1 个 key 被修改，则发起快照保存。 save 300 10：300 秒内如果超过 10 个 key 被修改，则快照保存。\nAppend-only file（缩写为 aof）：将读写操作存放到文件中。\n\n\n由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。\naof 比快照方式有更好的持久化性，但是由于 OS 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 Redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。\n\nappendonly yes //启用 aof 持久化方式# appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中# appendfsync no //完全依赖 os，性能最好，持久化没有保证\n\n","categories":["技术"],"tags":["Redis"]},{"title":"常用的 Redis 管理命令","url":"/2020/06/23/2020-6-23-redis-common-commands/","content":"常用的 Redis 管理命令EXISTS and DELexists key：判断一个 key 是否存在，存在返回 1，否则返回 0 。\ndel key：删除某个 key，或是一系列 key，比如：del key1 key2 key3 key4。成功返回 1，失败返回 0（key 值不存在）。\n&gt; set mykey hello\t#设置一个 mykey 值为 hello&gt; exists mykey\t\t#此时 mykey 存在，返回 1&gt; del mykey\t\t\t#删除 mykey&gt; exists mykey\t\t#此时不存在，返回 0\n\nTYPE and KEYStype key：返回某个 key 元素的数据类型（none：不存在，string：字符，list：列表，set：元组，zset：有序集合，hash：哈希），key 不存在返回空。\nkeys key—pattern：返回匹配的 key 列表，比如：keys foo* 表示查找 foo 开头的 keys。\n&gt; set mykey x&gt; type mykey&gt; keys my*&gt; del mykey&gt; keys my*&gt; type mykey\n\nRANDOMKEY and CLEARrandomkey：随机获得一个已经存在的 key，如果当前数据库为空，则返回空字符串。\nclear：清除界面。\nRENAME and RENAMENXrename oldname newname：更改 key 的名字，新键如果存在将被覆盖。 \nrenamenx oldname newname：更改 key 的名字，新键如果存在则更新失败。\nDBSIZEdbsize：返回当前数据库的 key 的总数。\nRedis 时间相关命令限定 key 生存时间限定 key 的生存时间对于临时存储很有用处，避免进行大量的 DEL 操作。\nexpire：设置某个 key 的过期时间（秒），比如：expire bruce 1000 表示设置 bruce 这个 key 1000 秒后系统自动删除，注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。\n&gt; set key some-value\t#设置 key 值为 some-value&gt; expire key 10\t\t#设置 key 生存时间为 10s&gt; get key     # 马上执行此命令，返回 some-value&gt; get key     # 10s后执行此命令，返回 nil\n\n查询 key 的剩余生存时间限时操作可以在 set 命令中实现，并且可用 ttl 命令查询 key 剩余生存时间。\nttl：查找某个 key 还有多长时间过期，返回时间单位为秒。\n&gt; set key 100 ex 30\t#设置 key 值为 100 指定存活时间为 30s&gt; ttl key\t#返回 key 的存活剩余时间\n\n清除 keyflushdb：清空当前数据库中的所有键。 flushall：清空所有数据库中的所有键。\nRedis 设置相关命令\nRedis 有其配置文件，可以通过 client-command 窗口查看或者更改相关配置。下面介绍相关命令。\n\nCONFIG GET and CONFIG SETconfig get：用来读取运行 Redis 服务器的配置参数。 config set：用于更改运行 Redis 服务器的配置参数。 auth：认证密码。\n&gt; config get requirepass  # 查看密码，未设置密码时返回“”&gt; config set requirepass test123  # 设置密码为 test123，如果想清除密码，重新把值改为 “” 即可&gt; set test 1  #想要设置 test 值为 1，由于设置了密码且没有认证，报错&gt; auth test123  # 认证密码&gt; set test 1\t#OK\n\n\n可以通过修改 Redis 的配置文件 redis.conf 修改密码。\n\nconfig get 命令是以 list 的 key-value 对显示的，如查询数据类型的最大条目\nconfig resetstat：重置数据统计报告，通常返回值为“OK”\n查询嘻嘻info [section]：查询 Redis 相关信息。\ninfo 命令可以查询 Redis 几乎所有的信息，其命令选项有如下：\n\nserver: Redis server 的常规信息\nclients: Client 的连接选项\nmemory: 存储占用相关信息\npersistence: RDB and AOF 相关信息\nstats: 常规统计\nreplication: Master&#x2F;Slave 请求信息\ncpu: CPU 占用信息统计\ncluster: Redis 集群信息\nkeyspace: 数据库信息统计\nall: 返回所有信息\ndefault: 返回常规设置信息\n\n\n若命令参数为空，info 命令返回所有信息。\n\n\n更多关于 Redis 的配置，Redis 的官网中有详细介绍哦，GO\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis 数据类型（二）","url":"/2020/06/23/2020-6-23-redis-data-type/","content":"Redis 数据类型（二）无序集合Redis 集合（Set）是一个无序的字符串集合。她可以以在 O(1)的的时间复杂度完成添加、删除以及测试元素是否存在。同时 Redis 集合还提供一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions），求交集（intersections），找出不同的元素（differences of sets）。\n&gt; sadd myset 1 2 3\t#向名为 myset 的集合中添加 1 2 3&gt; smembers myset\t#用于查看集合\n\nsismember 用于查看集合是否存在，匹配项包括集合名和元素（用于查看该元素是否是集合的成员）。匹配成功返回 1，匹配失败返回 0。\n&gt; sismember myset 3\t\t#此时存在，返回 1&gt; sismember myset 30\t#此时不存在，返回 0&gt; sismember mys 3\t\t#此时不存在，返回 0\n\n有序集合Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每一个成员都关联了一个权值，这个权值被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是权值可以是重复的。\n因为是有序集合所以在添加、删除和更新时间复杂虽然比无序集合要慢，但依旧可以达到 O(log(n)) 的时间复杂度。因为元素是有序的，所以她可以很轻松的根据权值 (score) 或者次序 (position) 来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复元素的自能列表。\nzadd 与 sadd 类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。\n&gt; zadd hackers 1940 &quot;Alan Kay&quot;\t\t#向名为 hachers 的有序集合中添加权值为 1940 的字符串 “Alan Kay”&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;&gt; zadd hackers 1953 &quot;Richard Stallman&quot;&gt; zadd hackers 1949 &quot;Anita Borg&quot;&gt; zadd hackers 1965 &quot;Yukihiro Matsumoto&quot;&gt; zadd hackers 1914 &quot;Hedy Lamarr&quot;&gt; zadd hackers 1916 &quot;Claude Shannon&quot;&gt; zadd hackers 1969 &quot;Linus Torvalds&quot;&gt; zadd hackers 1912 &quot;Alan Turing&quot;\n\n查看集合：zrange 是查看正序的集合，zrevrange 是查看反序的集合。0 表示集合第一个元素，-1 表示集合的倒数第一个元素。\n&gt; zrange hackers 0 -1&gt; zrevrange hackers 0 -1 withscores\n\n\n使用 withscores 参数可以返回权值。\n\nRedis 的数据类型就简单的了解到这里啦，如果你想了解更多不如到Redis 官方网站看看吧\n","categories":["技术"],"tags":["Redis"]},{"title":"浅谈 TCP 协议（二）","url":"/2020/06/24/2020-6-24-TCP-2/","content":"TCP报文段的首部格式TCP虽然是面向字节流的，但是TCP传送的数据单元却是报文段，而且TCP的全部功能都体现在它的首部中各个字段。\n\n源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。\n序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。\n确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501 - 700），这表明B正确收到了A发送的到序号700为止的数据，因此，B期望收到A的下一个数据序号为701，于是B在发送给A的确认报文段中把确认号置位701。总之，若确认号为N，则表明到N-1为止的所有数据都已正确收到。\n数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。\n保留字段——占 6 位，保留为今后使用，但目前应置为 0\n紧急 URG —— 当 URG  &#x3D;  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)\n确认 ACK —— 只有当 ACK &#x3D; 1 时确认号字段才有效。当 ACK &#x3D; 0 时，确认号无效。TCP规定，在建立连接后所有传送的报文段都必须把ACK置1\n推送 PSH (PuSH) —— 接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n复位 RST (ReSeT) —— 当 RST &#x3D; 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。\n同步 SYN —— 在连接建立时用来同步序号，当SYN &#x3D; 1而ACK &#x3D; 0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应的报文段中使SYN &#x3D; 1和ACK &#x3D; 1。所以，SYN &#x3D; 1 表示这是一个连接请求或连接接受报文。\n终止 FIN (FINis) —— 用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n窗口字段 —— 占 2 字节，窗口值是[0,2^16 -1]之间的整数。窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之窗口值作为接收方让发送方设置其发送窗口的依据。例如。设确认号是701，窗口字段是1000.这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节序号701-1700）的接收缓存空间。总之，窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着\n检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。与UDP一样在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。\n紧急指针字段 —— 占 16 位，仅在URG &#x3D; 1时才有意义，它指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面，因此紧急指针指出了紧急数据的末尾在报文段中的位置）。\n选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。\n其他选项\n\n窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。\n时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。\n选择确认选项\n\n填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。\n","categories":["技术"],"tags":["Network TCP"]},{"title":"浅谈 TCP 协议（一）","url":"/2020/06/24/2020-6-24-TCP/","content":"传输控制协议 TCP 概述TCP 协议比较复杂，这里只对 TCP 协议进行一般介绍。\nTCP 最主要的特点\nTCP 是面向连接的运输层协议。也就是说，应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在数据传输完毕后，必须释放已经建立的 TCP 连接。\n每一条 TCP 连接只能有两个端点（endpoint）。每一条 TCP 连接只能是点对点（一对一）。\nTCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复并且按序到达。\nTPC 提供全双工通信。\n面向字节流。TCP 中的 “流” 指的是流入到进程或从进程流出的字节序列。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成一连串的无结构的字节流。TCP 并不知道所传达的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有大小对应的关系，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。\n\nTCP的连接TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。这个端点叫做套接字（socket）或插口。根据 RFC 973 的定义：端口号拼接到（concatenated with）IP 地址即构成了套接字。每一条 TCP连接唯一的被通信两端的两个端点（即两个套接字）所确定。即：\n\nTCP连接 ::&#x3D; {socket1,socket2} &#x3D;&#x3D; {(IP1:port1),(IP2:port2)}\n\n总之，TCP 连接就是由协议软件所提供的一种抽象。有的时候我们为了方便说，在一个应用进程和另一个应用进程之间建立了一条 TCP 连接，但请记住：TCP 连接的端点是个很抽象的套接字，即（IP : 端口号）。也应记住：同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。\n可靠传输的工作原理TCP 发送的报文段是交个 IP 层传送的。但 IP 层只能提供尽最大努力交付的服务，因此，TCP 必须采取适当的措施来使得两个运输层之间的通信编的可靠。\n停止等待协议\n在计算机网络发展的初期，通信链路不太可靠，因此在链路层传送数据时都要采用可靠的通信协议。其中最简单的协议就是 “停止等待协议”。\n\n停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。\n\n无差错情况\n\n\n出差错情况\n\n问题 1\n\n\n在接收方 B 会出现两种情况：（1）B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。\n\n\n\n （2）M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。\n\n解决方法：超时重传\nA 为每一个已发送的分组都设置了一个超时计时器。\nA 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。\n\n\n问题 2\n\n\n若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？\n\n\n解决方法：编号A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。\n\n\n\n\n\n像上述的这种可靠的传输协议常称为自动重传协议 ARQ（Automatic Repeat reQuest）。\n停止等待协议的优点是简单，缺点是信道的利用率太低。为了提高传输效率，发送方可以不适用低效率的停止等待协议，而是采用流水线传输。\n\n流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不断地在传送，从而提高信道的利用率。\n流水线传输时，会使用到连续 ARQ 协议和滑动窗口协议。\n连续 ARQ 协议滑动窗口协议比较复杂，是TCP协议的精髓所在，在这里先给出ARQ协议最基本的概念，但不涉及到许多细节问题。\n\n发送方维持的发送窗口，他的意义是：位于发送窗口内的 5 个分组都可以连续发送出去，而不需要等待对方确认。从而提高信道的利用率。当发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。\n累积确认：接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已正确收到了。累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。\nGo-back-N：当接收方检测出时序的信息后，要求发送方重发最后一个正确接受的信息帧之后的所有未被确认的帧；或者当发送方发送了n个帧后，若发现该n帧的前一帧在计时器超时区间内仍未返回其确认信息，则该帧被判定为出错或丢失，此时发送方不得不重新发送该出错帧及其后的n帧。\n以字节为单位的滑动窗口 \n\n超时重传时间的选择\n重传机制是 TCP 中最重要和最复杂的问题之一。\nTCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。\n\n往返时延的方差很大由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。\n\n加权平均往返时间RTTTCP才用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。\nTCP 保留了 RTT 的一个加权平均往返时间 RTTs（这又称为平滑（smooth）的往返时间，因为是加权平均，所以是平滑的）。 第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：\n\n式中，0&#x3D;&lt;a&lt;1。若 a 很接近于零，表示 RTT 值更新较慢(新的RTTs值和旧的RTTs值相比变化不大)。若选择 a 接近于 1，则表示 RTT 值更新较快(新的RTTs值受新的RTT样本的影响较大)。 RFC 2988 推荐的 a 值为 1&#x2F;8，即 0.125。\n超时重传时间RTO显然，RTO 应略大于上面得出的加权平均往返时间 RTTsRFC 2988 建议使用下式计算 RTO：\n\nRTTD 是 RTT 的偏差的加权平均值，他与RTTs和新的RTT样本之差有关。 RFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD：\n\nβ是个小于 1 的系数，其推荐值是 1&#x2F;4，即 0.25。\n然而往返时间的测量是相当复杂的：\n\nKarn 算法：\n\n为了解决上面那个问题，Karn提出了一个算法.\n在计算平均往返时间 RTT 时，只要**报文段重传了，就不采用其往返时间样本。这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。 **\n\n但是，这又有了新的问题、设想出现这样的情况：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。\n修正的 Karn 算法\n\n系数 γ 的典型值是 2 。当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。实践证明，这种策略较为合理。\n","categories":["技术"],"tags":["Network TCP"]},{"title":"浅谈 TCP 三次握手、四次挥手","url":"/2020/06/25/2020-6-25-TCP-3/","content":"1.1 TCP 三次握手如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。 !\n简单示意图： \n\n客户端–发送带有 SYN 标志的数据包–一次握手–服务端\n服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端\n客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端\n\n1.2 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常\n第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n所以三次握手就能确认双发收发功能都正常，缺一不可。\n1.3 第2次握手传回了ACK，为什么还要传回SYN？接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”\n\nSYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n\n2.1 四次挥手\n\n客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n2.2 为什么客户端最后还要等待 2 MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n\n第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n\n","categories":["技术"],"tags":["Network TCP"]},{"title":"Git 本地仓库同时推送多个远程仓库","url":"/2020/06/26/2020-6-26-bind_one_git_local_repository_to_multiple_remote_repositories/","content":"1. 生成新的 SSH keyssh-keygen -t rsa -C  &#x27;xxxxxxxx@xxx.com&#x27; -f id_rsa_tencen\n\n2. 上传公钥到git仓库提供商Gitee 设置账户 SSH 公钥用户可以通过主页右上角 「个人设置」-&gt;「安全设置」-&gt;「SSH公钥」-&gt;「添加公钥」 ，添加生成的 public key 添加到当前账户中。\n\n需要注意： 添加公钥需要验证用户密码\n\n\nGithub 设置账户 SSH 公钥用户可以通过主页右上角 「头像按钮」-&gt;「Settings」-&gt;「SSH and GPG keys」-&gt;「New SSH key (or Add SSH key)」 ，添加生成的 public key 添加到当前账户中。\n\n配置 SSH 的 config 文件找到 .ssh 目录下的 config 文件并编辑（如果没有 config 文件则自己创建一个）\ncd ~/.ssh/vim config\n\n#这里我又两个Gitee的仓库， 所以Host要自定义为不同的两个名字#HostName 仓库的域名，如仓库在 Github 就写 github.com#User说明该配置的用户#IdentityFile 指定了该使用哪个ssh key文件，这里的key文件一定指的是私钥文件Host name1\t\tHostName gitee.com\tUser userName\tPreferredAuthentications publickey\tPasswordAuthentication yes\tIdentityFile ~/.ssh/name1_id_rsaHost name2\tHostName gitee.com\tUser userName\tPreferredAuthentications publickey\tPasswordAuthentication yes\tIdentityFile ~/.ssh/name2_id_rsaHost github.com        HostName github.com        User userName        PreferredAuthentications publickey        PasswordAuthentication yes        IdentityFile ~/.ssh/id_rsa\t\n\n完成后可以使用（三条命令分别对应 config 配置文件中的配置）\n$ ssh -T git@name1$ ssh -T git@name2$ ssh -T git@github.com\n\n\n\n绑定远程仓库在创建好本地仓库和远程仓库后，我们要绑定本地仓库到多个远程仓库\n$ git remote add origin git@name1:xxx.git$ git remote set-url origin --add git@name2:xxx.git$ git remote set-url origin --add git@github.com:xxx.git\n\n然后我们推送本地代码到远程仓库\n$ git push origin master\n\n这时发现代码已经被推送到了撒个仓库中啦，是不是很方便呢。\n","categories":["技术"],"tags":["Git"]},{"title":"初探 RabbitMQ （一）","url":"/2020/06/27/2020-6-27-probe-in-RabbitMQ/","content":"简介RabbitMQ 是高级消息队列协议（AMQP）的开源消息代理软件。\nRabbitMQ 服务器是用 Erlang 语言编写的，消息系统允许软件、应用相互连接和扩展。这些应用可以相互链接起来组成一个更大的应用，或者将用户设备和数据进行连接。消息系统通过将消息的发送和接收分离来实现应用程序的异步和解耦。\n或许你正在考虑进行数据投递，非阻塞操作或推送通知。或许你想要实现发布 &#x2F; 订阅，异步处理，或者工作队列。所有这些都可以通过消息实现。RabbitMQ 是一个消息代理 - 一个消息系统的媒介。它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。\n功能亮点\n\n可靠性：RabbitMQ 提供了各种功能，让你权衡性能与可靠性，其中包括持久性，交付确认和高可用性。\n灵活的路由：消息在到达队列之前，通过交换机的路由。RabbitMQ 为典型的路由逻辑提供了几个内置的交换机类型。对于更复杂的路由，则可以绑定几种交换机一起使用甚至可以自己实现交换机类型，并且把它作为一个插件的来使用。\n集群：在本地网络上的几个 RabbitMQ 服务器可以聚集在一起，作为一个独立的逻辑代理来使用。\n联合：对于服务器来说，它比集群需要更多的松散和非可靠链接。为此 RabbitMQ 提供了联合模型。\n高度可用队列：在群集中，队列可以被镜像到几个机器中，确保您的消息即使在出现硬件故障的安全。\n多协议：RabbitMQ 支持上各种消息传递协议的消息传送.\n许多客户端：有你能想到的几乎任何语言 RabbitMQ 客户端。\n管理用户界面：RabbitMQ 附带一个简单使用管理用户界面，允许您监视和控制您的消息代理的各个方面。\n追踪：如果您的消息系统行为异常，RabbitMQ 提供跟踪支持，让你找出问题是什么。\n插件系统：RabbitMQ 附带各种插件扩展，并且你也可以写你自己插件.\n商业支持:提供商业支持、 培训和咨询。\n大型社区:有一个庞大的社区 RabbitMQ，有各种各样的客户端、 插件、 指南等。\n\n安装如果使用的是 Debain&#x2F;Ubuntu 系统，你可以和往常一样非常方便的从 apt 中直接拿到你想要的\n# 更新软件包列表$ sudo apt-get update# 安装 RabbitMQ Server$ sudo apt-get install -y rabbitmq-server\n\n其他系统系统可以参考官方文档\n管理服务器当 RabbitMQ 安装完毕的时候服务器就会像后台程序一般运行起来了。作为一个管理员，可以像平常一样在 Debian 中使用以下命令启动和关闭服务\n服务器相关命令：\n\n启动\n$ sudo service rabbitmq-server start\n\n\n\n关闭\n$ sudo service rabbitmq-server stop\n\n\n\n查看状态\n$ sudo service rabbitmq-server status\n\n日志服务器的输出被发送到 RABBITMQ_LOG_BASE 目录的 RABBITMQ_NODENAME.log 文件中。一些额外的信息会被写入到 RABBITMQ_NODENAME-sasl.log 文件中。\n代理总是会把新的信息添加到日志文件尾部，所以完整的日志历史可以被保存下来。\n你可以使用 logrotate 程序来执行必要的循环和压缩工作，并且你还可以更改它。默认情况下，脚本会每周执行一次对这些位于 /var/log/rabbitmq/ 文件夹中的日志的处理。\n你可以查看 /etc/logrotate.d/rabbitmq-server 来对 logrotate 进行配置。\n查看日志的内容可以使用如下的方式：\n# servername 是指你的主机名$ less  /var/log/rabbitmq/rabbit@servername.log\n\nRabbitMQ 所支持的编程语言\nC# (using .net&#x2F;c# client)\nclojure (using Langohr)\nerlang (using erlang client)\njava (using java client)\njavascript&#x2F;node.js (using amqp.node)\nperl (using Net::RabbitFoot)\npython (using pika)\npython-puka (using puka)\nruby (using Bunny)\nruby (using amqp gem)\n\n","categories":["技术"],"tags":["RabbitMQ"]},{"title":"初探 RabbitMQ （二）","url":"/2020/06/28/2020-6-28-probe-in-RabbitMQ/","content":"Hello World 测试实验内容通过一个程序发送 “Hello world”，另一个程序接受消息并且打印到屏幕上。\n\n生产者（Producer）把消息发送到一个名为 “hello” 的队列中。消费者（Consumer）从这个队列中获取消息。\n安装 RabbitMQ 库RabbitMQ 使用的是 AMQP 协议。要使用 rabbitmq，你需要一个库来解读这个协议。几乎所有的编程语言都有可选择的库。python 也是一样，可以从以下几个库中选择，他们都可以实现 python 与 rabbitmq 的对接：\n\npy-amqplib\ntxAMQP\npika\n\n这次实验我们用 pika 来做演示，通过 pip 来安装：\n# 更新软件包列表$ sudo apt-get update# 安装所需要的依赖$ sudo apt-get install -y python-pip git-core  # 更新 pip$ sudo pip install --upgrade pip# 安装 pika$ sudo pip3 install pika  \n\n发送数据send\n#!/usr/bin/env python3import pika#创建连接connection = pika.BlockingConnection(pika.ConnectionParameters(        host=&#x27;localhost&#x27;))channel = connection.channel()#声明一个名为 hello 的队列channel.queue_declare(queue=&#x27;hello&#x27;)#在 RabbitMQ 中，消息是不能直接发送到队列，它需要发送到交换机（exchange）中，它使用一个空字符串来标识。交换机允许我们指定某条消息需要投递到哪个队列。 routing_key 参数必须指定为队列的名称channel.basic_publish(exchange=&#x27;&#x27;,                      routing_key=&#x27;hello&#x27;,                      body=&#x27;Hello World!&#x27;)print(&quot; [x] Sent &#x27;Hello World!&#x27;&quot;)connection.close()\n\n获取数据receive\n#!/usr/bin/env python3import pika# 创建连接connection = pika.BlockingConnection(pika.ConnectionParameters(        host=&#x27;localhost&#x27;))channel = connection.channel()#声明 hello 队列channel.queue_declare(queue=&#x27;hello&#x27;)#定义一个回调函数def callback(ch, method, properties, body):    print(&quot; [x] Received %r&quot; % body)#订阅某 hello 队列中的消息收下一条消息#auto_ack 是否自动确认消息,true自动确认#on_message_callback 绑定消息回调函数为 callbackchannel.basic_consume(queue=&#x27;hello&#x27;,                      auto_ack=True,                      on_message_callback=callback)#打印一条提示信息print(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;)#开始接收 hello 队列中的消息channel.start_consuming()\n\n\n上述代码中我们重复声明了 hello 队列 —— 我们已经在前面的代码中声明过它了。如果我们确定了队列是已经存在的，那么我们可以不这么做，比如此前预先运行了 send 程序。可是我们并不确定哪个程序会首先运行。这种情况下，在程序中重复将队列重复声明一下是种值得推荐的做法.\n\n运行结果：\n运行 send 程序：\n运行 receive 程序：\n成功了！我们已经通过 RabbitMQ 发送第一条消息。你也许已经注意到了，receive.py 程序并没有退出。它一直在准备获取消息，你可以通过 Ctrl + C 来中止它。\n","categories":["技术"],"tags":["RabbitMQ"]},{"title":"Java并发编程的艺术读后总结（二）","url":"/2020/06/29/2020-6-28-the-art-of-java-concurrency-programming-2/","content":"Java 并发机制的底层实现原理Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终需要转化为汇编指令在 CPU 上运行， Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。\nvolatile 的应用volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的”可见性“。\nJava 语言规范的第 3 版中对 volatile 的定义：\n\n Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。\n\nvolatile变量在进行写操作时转化成汇编语言会多出一行 lock 前缀的指令，这个指令会引起两个步骤\n\n将当前CPU 缓存行（缓存的最小操作单位）的数据写回系统内存。为了提高处理速度，CPU不直接和内存通信，而是先将系统内存的数据读到内部缓存后再进行操作，操作完后也不知道什么时候写回内存。但现在，JVM会向CPU发送一条lock前缀的指令，将这个变量所在的缓存行写回到系统内存中。\n这个写回内存的操作会使其他CPU里缓存了当前内存地址的数据无效。为了保证各个处理器的缓存是一致的，就是实现缓存一致性协议，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里。\n\nsynchronized 的实现原理与应用利用 synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。具体表现形式：\n\n对于普通的同步方法，锁是当前实例对象。\n对于静态同步方法，锁是当前类 Class 对象。\n对于同步方法快，所示 Synchronized 括号里配置的对象。\n\nJava 对象头synchronized的锁是存在 Java 对象头里的，Java对象头里的Mark Word里默认存书对象的HashCode、分代年龄和锁标记位，如下图。存储的数据会随锁标志位的变化而变化。 \n\n锁的升级与对比Java SE 1.6 中，锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，这是为了提高获得锁和释放锁的效率。\n\n偏向锁\n当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。 如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。\n偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。\n关闭偏向锁，程序默认进轻量级锁状态。\n\n\n轻量级锁\n线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word 。然后线程尝试使用CAS将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n轻量级解锁时，会使用原子的CAS操作将 Displaced Mark Word 替换回到对象头，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。\n\n\n锁的优缺点对比\n\n\n\n原子操作的实现原理原子（atomic）本意是”不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。\n\nCPU 术语\n\n\n处理器如何实现原子操作\n\n使用总线锁保证原子性，所谓总线锁就是使用处理器提供一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。\n\n使用缓存锁来保证原子性，“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当太执行锁操作写回到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。但是有两种情况下处理器不会使用缓存锁定。\n\n当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。\n有些处理器不支持缓存锁定。\n\n\n缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效\n\n\n\n\nJava 如何实现原子操作\n\n使用锁来实现原子操作\n锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。\n\n\n使用循环 CAS 实现原子操作，自旋 CAS 实现的基本思路就是循环进行 CAS 操作直到成功为止。\nCAS 操作的三大问题\nABA 问题。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。\n循环时长开销大。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。\n只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。\n\n\n\n\n\n\n\n","categories":["技术"],"tags":["并发编程"]},{"title":"Java并发编程的艺术读后总结（一）","url":"/2020/06/28/2020-6-28-the-art-of-java-concurrency-programming/","content":"并发编程的挑战上下文切换CPU 通过时间片的分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。这个任务从保存到再加载的的过程就是一次上下文切换。\n如何减少上下文切换减少上下文切换的方法有无锁并发编程、CAS 算法、使用最少线程和使用协程。\n\n无锁并发编程。对线程竞争锁时，会引起上下文切花，所以多线程处理数据时，可以用一些办法来避免使用锁，如果将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。\nCAS 算法。Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。\n使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样就会造成大量线程都处于等待状态。\n协程：在单线程里实现多任务的调度，并在但县城里维持多个任务之间的切换。\n\n死锁锁是个非常有用的工具，运用场景非常多，使用简单且易于理解。但同时它也会带来一些困扰，那就是可能会引起死锁。\n避免死锁的常见方法：\n\n避免一个线程同时获取多个锁\n避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。\n尝试使用定时锁，使用 lock.tryLock(timeout) 来代替使用内部锁机制。\n对于数据库锁，加锁和解锁必须在一个数据库的连接里，否则会出现解锁失败的情况。\n\n资源限制的挑战资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。这时我们需要根据拨通的资源限制调整程序的并发力度。有数据库操作时，设计数据库连接数，如果 SQL 语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。\n","categories":["技术"],"tags":["并发编程"]},{"title":"初探 RabbitMQ （三）","url":"/2020/06/29/2020-6-29-probe-in-RabbitMQ/","content":"工作队列前面写了一个从已知队列中发送和获取消息的程序。现在我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。\n工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。\n\n这个概念在网络应用中是非常有用的，它可以在短暂的 HTTP 请求中处理一些复杂的任务。\n循环调度使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。\n默认来说，RabbitMQ 会按顺序得把消息发送给每个消费者（consumer）。平均每个消费者都会收到同等数量得消息。这种发送消息得方式叫做——轮询（round-robin）。\n消息确认当处理一个比较耗时得任务的时候，你也许想知道消费者（consumers）是否运行到一半就挂掉。当前的代码中，当消息被 RabbitMQ 发送给消费者（consumers）之后，马上就会在内存中移除。这种情况，你只要把一个工作者（worker）停止，正在处理的消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。\n我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望任务会重新发送给其他的工作者（worker）。\n为了防止消息丢失，RabbitMQ 提供了消息响应（acknowledgments）。消费者会通过一个 ack（响应），告诉 RabbitMQ 已经收到并处理了某条消息，然后 RabbitMQ 就会释放并删除这条消息。\n如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ 就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，及时工作者（workers）偶尔的挂掉，也不会丢失消息。\n消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ 会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。\n消息响应默认是开启的。之前的例子中我们可以使用 auto_ack=True 标识把它关闭。是时候移除这个标识了，当工作者（worker）完成了任务，就发送一个响应。\n消息持久化如果你没有特意告诉 RabbitMQ，那么在它退出或者崩溃的时候，将会丢失所有队列和消息。为了确保信息不会丢失，有两个事情是需要注意的：我们必须把 “队列” 和 “消息” 设为持久化。\n首先，为了不让队列消失，需要把队列声明为持久化（durable）。\n声明一个名为task_queue持久化队列：\n# 持久化一个队列，名为 task_queuechannel.queue_declare(queue=&#x27;task_queue&#x27;, durable=True)\n\n并且这个 queue_declare 必须在生产者（producer）和消费者（consumer）对应的代码中修改。这时候，我们就可以确保在 RabbitMQ 重启之后 queue_declare 队列不会丢失。另外，我们需要把我们的消息也要设为持久化——将 delivery_mode 的属性设为 2:\nchannel.basic_publish(exchange=&#x27;&#x27;,                      routing_key=&#x27;task_queue&#x27;,                      body=message,                      properties=pika.BasicProperties(                         # 消息持久化                         delivery_mode = 2,                       ))print(&quot; [x] Sent %r&quot; % message)\n\n\n注意：消息持久化\n将消息设为持久化并不能完全保证不会丢失。以上代码只是告诉了 RabbitMQ 要把消息存到硬盘，但从 RabbitMQ 收到消息到保存之间还是有一个很小的间隔时间。因为 RabbitMQ 并不是所有的消息都使用 fsync(2) —— 它有可能只是保存到缓存中，并不一定会写到硬盘中。并不能保证真正的持久化，但已经足够应付我们的简单工作队列。如果你一定要保证持久化，你需要改写你的代码来支持事务（transaction）。\n\n公平调度你应该已经注意到，RabbitMQ 并没有按照我们期望的那让进行分发，比如有两个工作者（workers），处理奇数消息的比较繁忙，处理偶数的比较轻松。然而 RabbitMQ 并不知情，他仍然一如既往的派发消息。\n知识因为 RabbitMQ 只管分发进入队列的消息，不会关心多少消费者（consumer）没有做出响应。它盲目的把 n 条消息发给 n 个消费者。\n\n我们可以使用 basic.qos 方法，并设置 prefetch_count=1。这样是告诉 RabbitMQ ，再同一时刻，不要发送超过 1 条消息给一个工作者（worker），直到它已经处理了上一条消息并且作出了响应。这样，RabbitMQ 就会把消息分发给下一个空闲的工作者（worker）:\nchannel.basic_qos(prefetch_count=1)\n\n\n关于队列大小\n如果所有的工作者都处理繁忙状态，你的队列就会被填满。你需要留意这个问题，要么添加更多的工作者（workers），要么使用其他策略。\n\n","categories":["技术"],"tags":["RabbitMQ"]},{"title":"初探 RabbitMQ （四）","url":"/2020/06/30/2020-6-30-probe-in-RabbitMQ/","content":"发布与订阅 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。\n知识点\n交换机简介\n学习使用扇形交换机\n\n交换机\n发布者（producer)：发布消息的应用程序\n队列（queue）：用于消息存储的缓冲\n消费者（consumer）：接收消息的应用程序\n\nRabbitMQ 消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。\n发布者（producer）只需把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者接收消息，一边把消息消息推送到队列。交换机必须知道如何处理它接收的消息，是应该推送到指定的队列还是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。\n\n有几个可供选择的交换机类型：直连交换机（direct），主题交换机（topic），头交换机（headers）和扇形交换机（fanout）。\n我们在这里主要说明最后一个 – 扇形交换机。先创建一个 fanout 类型的交换机，命名为 logs ：\nchannel.exchange_declare(exchange=&#x27;logs&#x27;,                         type=&#x27;fanout&#x27;)\n\n扇形交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给所有的队列，这正是我们日志系统所需要的。\n\n$ sudo rabbitmqctl list_exchanges #rabbitmqctl 能够列出服务器上所有的交换机\n\n现在，我们就可以发送消息到一个具体名字的交换机了：\nchannel.basic_publish( exchange=&#x27;logs&#x27;, routing_key=&#x27;hello&#x27;,body=message)\n\n临时队列给一个队列命名是很重要的。我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享队列的话，给队列命名是十分重要的。\n但是这并不适合我们的日志系统。我们打算接收所有的日志消息，而不仅仅是一小部分。我们关心的是最近的消息而不是久的。为了解决这个问题，我们需要做两件事情。\n第一步，当我们连接上 RabbitMQ 的时候，我们需要一个全新的，空的队列。我们可以手动创建一个随机的队列名，或者让服务器为我们选择一个随机的队列名（推荐）。我们只需要在调用 queue_declare 方法的时候，不提供 queue 参数就可以了：\nresult = channel.queue_declare()\n\n这时候我们可以通过 result.method.queue 获得已经生成的随机队列名。它可能是这样子的：amq.gen-U0srCoW8TsaXjNh73pnVAw==。\n第二步，当与消费者（consumer）断开连接的时候，这个队列应当被立即删除。 exclusive 标识符即可达到此目的。\n绑定我们已经创建了一个扇形交换机（ fanout ）和一个队列。现在我们需要告诉交换机如何发送消息给我们的队列。\n\n交换机和队列之间的联系我们称之为绑定（ binding ）。\nchannel.queue_bind(exchange=&#x27;logs&#x27;,queue=result.method.queue)\n\n现在，logs 交换机将会把消息加到我们的队列中。\n","categories":["技术"],"tags":["RabbitMQ"]},{"title":"Java并发编程的艺术读后总结（三）","url":"/2020/06/30/2020-6-30-the-art-of-java-concurrency-programming/","content":"Java 内存模型Java 内存模型的基础并发编程的两个关键问题在并发编程中，需要初拉力两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。\nJava 内存模型的抽象结构在 Java 中，所有的实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享（这篇文章中我们将用“共享变量”这个术语代指实例域，静态域和数组元素）。\nJava线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\n\n源代码的重排序在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。\n\n编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n\n并发编程模型的分类现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致。\n这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序。\n\n为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为4类。\n\nStoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。\nhappens-before 简介happens-before规则：\n\n程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。\n监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。\nvolatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。\n传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。\n\n重排序重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。\n数据依赖性如果两个操作同时访问一个变量，且这两个操作中有一个是写操作，此时这两个操作之间就存在数据依赖性。\nas-if-serial 语义as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。\n\nas-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。\n\n程序顺序规则在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能提高并行度。编译器和处理器遵从这一目标，从happens-before的定义我们可以看出，JMM同样遵从这一目标。\n重排序对多线程的影响当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行该线程的处理器可以提前读取并计算，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当控制条件为 true 时，就把该计算结果写入变量中。\n在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。\n顺序一致性数据竞争与顺序一致性当程序未正确同步时，就可能会存在数据竞争。\nJMM对正确同步的多线程程序的内存一致性做了如下保证：\n\n如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步原语（synchronized、volatile和final）的正确使用。\n\n顺序一致性内存模型顺序一致性内存模型有两大特性。\n\n一个线程中的所有操作必须按照程序的顺序来执行。\n（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。\n\n\n在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读&#x2F;写操作。从上面的示意图可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读&#x2F;写操作串行化（即在顺序一致性模型中，所有操作之间具有全序关系）。\n\n虽然她很好，但是在 JMM 中并没有这个保证\n\n同步程序的顺序一致性效果顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。\nJMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。\n未同步程序的执行特性对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间（Pre-zeroed Memory）分配对象时，域的默认初始化已经完成了。\n未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。\n\n顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。\n顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。\nJMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读&#x2F;写操作都具有原子性。\n\nvolatile 的内存语义volatile 的特性volatile 变量自身具有以下特性：\n\n可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。\n原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性。\n\nvolatile 写 - 读建立的 happens-before 关系从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。请看下面使用volatile变量的示例代码。\nclass VolatileExample &#123;       int                    a = 0;       volatile boolean flag = false;       public void writer() &#123;           a = 1;　　　　　    // 1           flag = true;　　　  // 2       &#125;       public void reader() &#123;           if (flag) &#123;　　　　// 3               int i = a;　　 // 4               ……           &#125;       &#125;&#125;\n\n假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before规则，这个过程建立的happens-before关系可以分为3类：1）根据程序次序规则，1 happens-before 2;3 happens-before 4。2）根据volatile规则，2 happens-before 3。3）根据happens-before的传递性规则，1 happens-before 4。\nvolatile 写 - 读的内存语义volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内。\nvolatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\nvolatile 内存语义的实现\n\n当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。\n当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。\n当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。\n\n为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile读的前面插入一个StoreLoad屏障。JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。\nJSR-133 为什么要增强 volatile 的内存语义在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。\n在旧的内存模型中，volatile的写-读没有锁的释放-获所具有的内存语义。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。由于volatile仅仅保证对单个volatile变量的读&#x2F;写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。\n锁的内存语义（synchronized）释放锁的内存语义当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。\n获取锁的内存语义当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使临界区的代码必须从主内存中读取共享变量。\n锁内存语义的实现ReentrantLock的实现依赖于Java同步去框架AbstractQueuedSynchronzier（AQS）。AQS使用一个整形的volatile变量（Lock实现内存语义的关键）来维护同步状态。\nfinal域的内存语义在构造函数内对一个final域的写入，与随后把这个构造对象的引用复制给一个引用变阿亮，这两个操作之间不能重排序。初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。\n","categories":["技术"],"tags":["并发编程"]},{"title":"设计模式简介（一）","url":"/2020/07/01/2020-7-1-design-patterns/","content":"什么是设计模式？在软件工程中，设计模式是对软件设计中普遍存在的各种问题，所提出的解决方案。\n换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。\n设计模式原则1、开闭原则（Open Close Principle）\n开闭原则的意思是：对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。\n2、里氏代换原则（Liskov Substitution Principle）\n里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n3、依赖倒转原则（Dependence Inversion Principle）\n这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。\n4、接口隔离原则（Interface Segregation Principle）\n这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调低依赖、低耦合。\n5、单一职责原则（Single Responsibility Principle）\n类的职责要单一，不能将太多的职责放在一个类中。\n可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。\n6、最少知道原则（Demeter Principle）\n最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。\n7、合成复用原则（Composite Reuse Principle）\n合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用组合/聚合的方式，尽量少使用甚至不使用继承关系。\n设计模式分类通常来说设计模式分为三大类：\n\n创建型模式，共 5 种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n行为型模式，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n下面用图片来整体描述一下设计模式之间的关系：\n\n我非常推荐大家读一本关于设计模式的书，《Head First 设计模式》，书中的讲解非常有趣，清晰易懂。\n","categories":["技术"],"tags":["Java设计模式"]},{"title":"剑指Offer","url":"/2020/07/11/2020-7-11-Offer/","content":"剑指 Offer 03. 数组中重复的数字找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 \n\n限制：\n2 &lt;= n &lt;= 100000\n\nclass Solution &#123;    public int findRepeatNumber(int[] nums) &#123;        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();        int repeat = -1;        for (int num : nums) &#123;            if (!set.add(num)) &#123;                repeat = num;                break;            &#125;        &#125;        return repeat;    &#125;&#125;\n\n\n\n\n\n剑指 Offer 05. 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。\n示例 1：\n输入：s &#x3D; “We are happy.”输出：”We%20are%20happy.”\n限制：\n0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000\nclass Solution &#123;    public String replaceSpace(String s) &#123;        int length = s.length();        char[] array = new char[length * 3];        int size = 0;        for (int i = 0; i &lt; length; i++) &#123;            char c = s.charAt(i);            if (c == &#x27; &#x27;) &#123;                array[size++] = &#x27;%&#x27;;                array[size++] = &#x27;2&#x27;;                array[size++] = &#x27;0&#x27;;            &#125; else &#123;                array[size++] = c;            &#125;        &#125;        String newStr = new String(array, 0, size);        return newStr;    &#125;&#125;\n\n剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head &#x3D; [1,3,2]输出：[2,3,1]\n限制：\n0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();        ListNode temp = head;        while (temp != null) &#123;            stack.push(temp);            temp = temp.next;        &#125;        int size = stack.size();        int[] print = new int[size];        for (int i = 0; i &lt; size; i++) &#123;            print[i] = stack.pop().val;        &#125;        return print;    &#125;&#125;\n\n剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1]示例 2：\n输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]提示：\n1 &lt;&#x3D; values &lt;&#x3D; 10000最多会对 appendTail、deleteHead 进行 10000 次调用\nclass CQueue &#123;    Deque&lt;Integer&gt; stack1;    Deque&lt;Integer&gt; stack2;        public CQueue() &#123;        stack1 = new LinkedList&lt;Integer&gt;();        stack2 = new LinkedList&lt;Integer&gt;();    &#125;        public void appendTail(int value) &#123;        stack1.push(value);    &#125;        public int deleteHead() &#123;        // 如果第二个栈为空        if (stack2.isEmpty()) &#123;            while (!stack1.isEmpty()) &#123;                stack2.push(stack1.pop());            &#125;        &#125;         if (stack2.isEmpty()) &#123;            return -1;        &#125; else &#123;            int deleteItem = stack2.pop();            return deleteItem;        &#125;    &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */\n\n剑指 Offer 10- I. 斐波那契数列难度简单75收藏分享切换为英文接收动态反馈\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\nF(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2输出：1\n\n示例 2：\n输入：n = 5输出：5\n\n提示：\n\n0 &lt;= n &lt;= 100\n\nclass Solution &#123;    public int fib(int n) &#123;        int f0 = 0, f1= 1;        for(int i=0; i&lt;n; i++) &#123;            int sum = (f0 + f1)%1000000007;            f0 = f1;            f1 = sum;        &#125;        return f0;    &#125;&#125;\n\n\n\n剑指 Offer 10- II. 青蛙跳台阶问题难度简单87收藏分享切换为英文接收动态反馈\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2输出：2\n\n示例 2：\n输入：n = 7输出：21\n\n示例 3：\n输入：n = 0输出：1\n\n提示：\n\n0 &lt;= n &lt;= 100\n\nclass Solution &#123;    public int numWays(int n) &#123;        int n0 = 1, n1 = 1;        int sum;        for(int i=0; i&lt;n; i++) &#123;            sum = (n0 + n1)%1000000007;            n0 = n1;            n1 = sum;        &#125;        return n0;    &#125;&#125;\n\n\n\n剑指 Offer 11. 旋转数组的最小数字难度简单175收藏分享切换为英文接收动态反馈\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 \n示例 1：\n输入：[3,4,5,1,2]输出：1\n\n示例 2：\n输入：[2,2,2,0,1]输出：0\n\nclass Solution &#123;    public int minArray(int[] numbers) &#123;        int min=numbers[0];        for(int i=1;i &lt; numbers.length; i++) &#123;            if(numbers[i]&lt;min)                min = numbers[i];        &#125;        return min;    &#125;&#125;\n\n\n\n剑指 Offer 15. 二进制中1的个数请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n示例 1：\n输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。示例 2：\n输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。示例 3：\n输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。\npublic class Solution &#123;    // you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        int ans=0;        while(n!=0) &#123;            ans += n &amp; 1;            n &gt;&gt;&gt;= 1;        &#125;        return ans;    &#125;&#125;\n\n\n\n剑指 Offer 17. 打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n示例 1:\n输入: n &#x3D; 1输出: [1,2,3,4,5,6,7,8,9]\n说明：\n用返回一个整数列表来代替打印n 为正整数\nclass Solution &#123;    public int[] printNumbers(int n) &#123;        n = (int)Math.pow(10,n)-1;        int[] arr = new int[n];        for(int i=0;i&lt;n;i++) &#123;            arr[i]=i+1;        &#125;        return arr;    &#125;&#125;\n\n剑指 Offer 21. 调整数组顺序使奇数位于偶数前面难度简单43\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n示例：\n输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。\n\n提示：\n\n1 &lt;= nums.length &lt;= 50000\n1 &lt;= nums[i] &lt;= 10000\n\nclass Solution &#123;    public int[] exchange(int[] nums) &#123;        int p=0,q=nums.length-1;        for(int i=0; i&lt;nums.length;) &#123;            if(i&gt;=q) break;            if(nums[i]%2==0) &#123;                int t = nums[q];                nums[q--] = nums[i];                nums[i] = t;            &#125; else &#123;                i++;            &#125;        &#125;        return nums;    &#125;&#125;\n\n\n\n剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。\n示例：\n给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.\n返回链表 4-&gt;5.\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        if(k==0)            return head;        int sum=0;        ListNode p=head;        while(p!=null) &#123;            sum++;            p=p.next;        &#125;        int i = sum-k+1;        p=head;        while(--i!=0) &#123;            p=p.next;        &#125;        return p;    &#125;&#125;\n\n剑指 Offer 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n限制：\n0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if(head==null || head.next==null)            return head;        ListNode p=head,n=p.next;        p.next = null;        while(n!=null) &#123;            ListNode t = n.next;            n.next = p;            p = n;            n = t;        &#125;        return p;    &#125;&#125;\n\n\n\n剑指 Offer 25. 合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n示例1：\n输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4限制：\n0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1==null)            return l2;        if(l2==null)            return l1;        ListNode ans= new ListNode();        ListNode p1=l1, p2=l2,tail=ans;        while(p1!=null&amp;&amp;p2!=null) &#123;            if(p1.val&lt;p2.val) &#123;                tail.next=p1;                p1=p1.next;            &#125; else &#123;                tail.next=p2;                p2=p2.next;            &#125;            tail=tail.next;        &#125;        if(p1==null) &#123;            tail.next = p2;        &#125;        if(p2==null) &#123;            tail.next = p1;        &#125;        return ans.next;    &#125;&#125;\n\n\n\n剑指 Offer 27. 二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n例如输入：\n 4\n\n   &#x2F;     2     7 &#x2F; \\   &#x2F; 1   3 6   9镜像输出：\n 4\n\n   &#x2F;     7     2 &#x2F; \\   &#x2F; 9   6 3   1\n示例 1：\n输入：root &#x3D; [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]\n限制：\n0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        return reverse(root);    &#125;    private static TreeNode reverse(TreeNode node) &#123;        if(node==null)            return null;        TreeNode temp = node.right;        node.right = node.left;        node.left = temp;        reverse(node.left);        reverse(node.right);        return node;    &#125;&#125;\n\n剑指 Offer 28. 对称的二叉树难度简单82收藏分享切换为英文关注反馈\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n  1  / \\ 2  2 / \\ / \\3  4 4  3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n1  / \\ 2  2  \\  \\  3   3\n\n示例 1：\n输入：root = [1,2,2,3,4,4,3]输出：true\n\n示例 2：\n输入：root = [1,2,2,null,3,null,3]输出：false\n\n限制：\n0 &lt;= 节点个数 &lt;= 1000\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        return root == null ? true : recur(root.left, root.right);    &#125;    boolean recur(TreeNode L, TreeNode R) &#123;        if(L == null &amp;&amp; R == null) return true;        if(L == null || R == null || L.val != R.val) return false;        return recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);    &#125;&#125;\n\n剑指 Offer 29. 顺时针打印矩阵难度简单152收藏分享切换为英文接收动态反馈\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n示例 1：\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]\n\n示例 2：\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n限制：\n\n0 &lt;= matrix.length &lt;= 100\n0 &lt;= matrix[i].length &lt;= 100\n\nclass Solution &#123;    public int[] spiralOrder(int[][] matrix) &#123;        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;            return new int[0];        &#125;        int rows = matrix.length, columns = matrix[0].length;        boolean[][] visited = new boolean[rows][columns];        int total = rows * columns;        int[] order = new int[total];        int row = 0, column = 0;        int[][] directions = \\&#123;\\&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0\\&#125;\\&#125;;        int directionIndex = 0;        for (int i = 0; i &lt; total; i++) &#123;            order[i] = matrix[row][column];            visited[row][column] = true;            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];            if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;                directionIndex = (directionIndex + 1) % 4;            &#125;            row += directions[directionIndex][0];            column += directions[directionIndex][1];        &#125;        return order;    &#125;&#125;\n\n\n\n剑指 Offer 30. 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n示例:\nMinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.\n\n\n\n/** * 难点实现 min() 的时间复杂度为 O(1)， * 实现思路：维护两个栈，栈 A 存储数据，栈 B 用于存储最小值， * 当栈 A push(x), x 比目前最小值还要小的数据时，B push(x); * 例如 * 如果 A [ 5 2 1 4 7 6 ] * 那么 B [ 5 2 1 ] */class MinStack &#123;    Stack&lt;Integer&gt; A, B;    public MinStack() &#123;        A = new Stack&lt;&gt;();        B = new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        A.add(x);        if(B.empty() || B.peek() &gt;= x)            B.add(x);    &#125;    public void pop() &#123;        if(A.pop().equals(B.peek()))            B.pop();    &#125;    public int top() &#123;        return A.peek();    &#125;    public int min() &#123;        return B.peek();    &#125;&#125;/**作者：jyd链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/\n\n\n\n剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如:给定二叉树: [3,9,20,null,null,15,7],\n3\n\n   &#x2F;   9  20    &#x2F;     15   7返回其层次遍历结果：\n[  [3],  [9,20],  [15,7]]\n提示：\n节点总数 &lt;&#x3D; 1000\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        if(root != null) queue.add(root);        while(!queue.isEmpty()) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();            for(int i = queue.size(); i &gt; 0; i--) &#123;                TreeNode node = queue.poll();                tmp.add(node.val);                if(node.left != null) queue.add(node.left);                if(node.right != null) queue.add(node.right);            &#125;            res.add(tmp);        &#125;        return res;    &#125;&#125;\n\n剑指 Offer 39. 数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1:\n输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2\n限制：\n1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int x = 0, votes = 0;        for(int num : nums)&#123;            if(votes == 0) x = num;            votes += num == x ? 1 : -1;        &#125;        return x;    &#125;&#125;\n\n剑指 Offer 50. 第一个只出现一次的字符难度简单45收藏分享切换为英文关注反馈\n在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n示例:\ns = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot;\n\n限制：\n0 &lt;= s 的长度 &lt;= 50000\n\nclass Solution &#123;    public char firstUniqChar(String s) &#123;        int[][] arr = new int[26][2];        for(int i=0; i&lt;s.length(); i++) &#123;            int index = s.charAt(i)- 97;            arr[index][0]=i;            arr[index][1]++;        &#125;        char ans=&#x27; &#x27;;        int min=100000;        for(int i=0; i&lt;arr.length; i++) &#123;            if(arr[i][1]==1 &amp;&amp; arr[i][0]&lt;min) &#123;                min = arr[i][0];                ans =(char)(i+97);            &#125;        &#125;        return ans;    &#125;&#125;\n\n\n\n剑指 Offer 52. 两个链表的第一个公共节点/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */import java.util.ArrayList;public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ArrayList&lt;ListNode&gt; listA = new ArrayList&lt;&gt;();        ArrayList&lt;ListNode&gt; listB = new ArrayList&lt;&gt;();        ListNode p = headA;        while(p != null) &#123;            listA.add(p);            p = p.next;        &#125;        p = headB;        while(p != null) &#123;            listB.add(p);            p = p.next;        &#125;        int i=listA.size()-1, j = listB.size()-1;        if(i&lt;0||j&lt;0)            return null;        ListNode t=null;        while(i&gt;=0&amp;&amp;j&gt;=0) &#123;            if(listA.get(i)!=listB.get(j))                break;            else &#123;                t=listA.get(i);                i--;                j--;            &#125;        &#125;        return t;    &#125;&#125;\n\n\n\n剑指 Offer 53 - I. 在排序数组中查找数字 I难度简单75\n统计一个数字在排序数组中出现的次数。\n示例 1:\n输入: nums = [5,7,7,8,8,10], target = 8输出: 2\n\n示例 2:\n输入: nums = [5,7,7,8,8,10], target = 6输出: 0\n\n限制：\n0 &lt;= 数组长度 &lt;= 50000\n\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        int ans=0;        for(int i=0; i&lt;nums.length; i++) &#123;            if(nums[i]==target)                ans++;        &#125;        return ans;    &#125;&#125;\n\n\n\n剑指 Offer 53 - II. 0～n-1中缺失的数字难度简单76收藏分享切换为英文接收动态反馈\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n示例 1:\n输入: [0,1,3]输出: 2\n\n示例 2:\n输入: [0,1,2,3,4,5,6,7,9]输出: 8\n\n限制：\n1 &lt;= 数组长度 &lt;= 10000\n\nclass Solution &#123;    public int missingNumber(int[] nums) &#123;        for(int i=0; i&lt;nums.length; i++) &#123;            if(nums[i]!=i)                return i;        &#125;        return nums.length;    &#125;&#125;\n\n\n\n剑指 Offer 54. 二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第k大的节点。\n示例 1:\n输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1   3  &#x2F;  1   4     2输出: 4示例 2:\n输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3       5      &#x2F;      3   6    &#x2F;    2   4  &#x2F; 1输出: 4\n限制：\n1 ≤ k ≤ 二叉搜索树元素个数\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int kthLargest(TreeNode root, int k) &#123;        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();        toArray(arr,root);        return arr.get(arr.size()-k);    &#125;    //中序遍历    private static void toArray(ArrayList&lt;Integer&gt; arr, TreeNode node) &#123;        if(node==null)            return;        toArray(arr,node.left);        arr.add(node.val);        toArray(arr,node.right);    &#125;&#125;\n\n\n\n剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n例如：\n给定二叉树 [3,9,20,null,null,15,7]，\n3\n\n   &#x2F;   9  20    &#x2F;     15   7返回它的最大深度 3 。\n提示：\n节点总数 &lt;&#x3D; 10000\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if(root==null)            return 0;        return Math.max(maxDepth(root.left)+1,maxDepth(root.right)+1);    &#125;&#125;\n\n剑指 Offer 55 - II. 平衡二叉树难度简单65收藏分享切换为英文关注反馈\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n  3 / \\9  20  /  \\ 15   7\n\n返回 true 。\n示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n      1     / \\    2   2   / \\  3   3 / \\4   4\n\n返回 false 。\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */ import java.lang.Math;class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        if(root==null)            return true;        if(root.left==null &amp;&amp; root.right==null)            return true;        boolean lr,rr;        lr = isBalanced(root.left);        rr = isBalanced(root.right);        int l,r;        l=depth(root.left);        r=depth(root.right);        return lr&amp;&amp;rr&amp;&amp;Math.abs(l-r)&lt;=1?true:false;    &#125;    public static int depth(TreeNode root) &#123;        if(root==null)            return 0;        if(root.left==null &amp;&amp; root.right==null)            return 1;        int l,r;        l = depth(root.left)+1;        r = depth(root.right)+1;        return Math.max(l,r);    &#125;&#125;\n\n\n\n剑指 Offer 57. 和为s的两个数字输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n示例 1：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[2,7] 或者 [7,2]示例 2：\n输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40输出：[10,30] 或者 [30,10]\n限制：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^51 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6\n来源：力扣（LeetCode）\nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int i = 0, j = nums.length - 1;        while(i &lt; j) &#123;            int s = nums[i] + nums[j];            if(s &lt; target) i++;            else if(s &gt; target) j--;            else return new int[] &#123; nums[i], nums[j] &#125;;        &#125;        return new int[0];    &#125;&#125;\n\n\n\n剑指 Offer 58 - I. 翻转单词顺序难度简单47收藏分享切换为英文接收动态反馈\n输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。\n示例 1：\n输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;\n\n示例 2：\n输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n示例 3：\n输入: &quot;a good   example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n说明：\n\n无空格字符构成一个单词。\n输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\nclass Solution &#123;    public String reverseWords(String s) &#123;        if (s == null || s.length() &lt;= 0 || s.trim().length() &lt;= 0) &#123;            return &quot;&quot;;        &#125;        String[] strs = s.split(&quot; &quot;);        int length = strs.length;        for (int i = 0; i &lt; length / 2; i++) &#123;            String tempStr = strs[i].trim();            strs[i] = strs[length - 1 - i].trim();            strs[length - 1 - i] = tempStr;        &#125;        StringBuilder builder = new StringBuilder(strs[0]);        for (int i = 1; i &lt; strs.length; i++) &#123;            if (strs[i].length() &gt; 0) &#123;                builder.append(&quot; &quot;).append(strs[i]);            &#125;        &#125;        return builder.toString();    &#125;&#125;\n\n\n\n剑指 Offer 58 - II. 左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。\n示例 1：\n输入: s &#x3D; “abcdefg”, k &#x3D; 2输出: “cdefgab”示例 2：\n输入: s &#x3D; “lrloseumgh”, k &#x3D; 6输出: “umghlrlose”\n限制：\n1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000\nclass Solution &#123;    public String reverseLeftWords(String s, int n) &#123;        return s.substring(n)+s.substring(0,n);    &#125;&#125;\n\n剑指 Offer 59 - I. 滑动窗口的最大值难度简单145收藏分享切换为英文接收动态反馈\n给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。\n示例:\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7\n\n提示：\n你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\\\nclass Solution &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        if(nums==null || nums.length == 0)            return new int[0];        int[] ans = new int[nums.length-k+1];        int index = 0;        for(int i=k-1; i&lt;nums.length; i++) &#123;            for(int j=0; j&lt;k; j++) &#123;                if(j==0)                    ans[index] = nums[i-j];                else if(ans[index] &lt; nums[i-j])                    ans[index] = nums[i-j];            &#125;            index++;        &#125;        return ans;    &#125;&#125;\t\n\n\n\n剑指 Offer 61. 扑克牌中的顺子难度简单78\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n示例 1:\n输入: [1,2,3,4,5]输出: True\n\n示例 2:\n输入: [0,0,1,2,5]输出: True\n\nclass Solution &#123;    public boolean isStraight(int[] nums) &#123;        Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();        int max = 0, min = 14;        for(int num : nums) &#123;            if(num == 0) continue; // 跳过大小王            max = Math.max(max, num); // 最大牌            min = Math.min(min, num); // 最小牌            if(repeat.contains(num)) return false; // 若有重复，提前返回 false            repeat.add(num); // 添加此牌至 Set        &#125;        return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子    &#125;&#125;\n\n\n\n剑指 Offer 62. 圆圈中最后剩下的数字0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n示例 1：\n输入: n &#x3D; 5, m &#x3D; 3输出: 3示例 2：\n输入: n &#x3D; 10, m &#x3D; 17输出: 2\n限制：\n1 &lt;&#x3D; n &lt;&#x3D; 10^51 &lt;&#x3D; m &lt;&#x3D; 10^6\n题解\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        int f = 0;        for (int i = 2; i != n + 1; ++i)            f = (m + f) % i;        return f;    &#125;&#125;\n\n剑指 Offer 64. 求1+2+…+n难度中等227收藏分享切换为英文接收动态反馈\n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n示例 1：\n输入: n = 3输出: 6\n\n示例 2：\n输入: n = 9输出: 45\n\n限制：\n\n1 &lt;= n &lt;= 10000\n\n/**/class Solution &#123;    public int sumNums(int n) &#123;        boolean x = n &gt; 1 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;        return n;    &#125;&#125;作者：jyd来源：力扣（LeetCode）\n\n\n\n剑指 Offer 65. 不用加减乘除做加法写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。\n示例:\n输入: a &#x3D; 1, b &#x3D; 1输出: 2\n提示：\na, b 均可能是负数或 0结果不会溢出 32 位整数\nclass Solution &#123;    public int add(int a, int b) &#123;        while(b != 0) &#123; // 当进位为 0 时跳出            int c = (a &amp; b) &lt;&lt; 1;  // c = 进位            a ^= b; // a = 非进位和            b = c; // b = 进位        &#125;        return a;    &#125;&#125;\n\n\n\n剑指 Offer 68 - I. 二叉搜索树的最近公共祖先剑指 Offer 68 - II. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]\n示例 1:\n输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:\n输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n说明:\n所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。\nclass Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if(root == null || root == p || root == q) return root;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        if(left == null) return right;        if(right == null) return left;        return root;    &#125;&#125;\n\n","categories":["技术"],"tags":["LeetCode"]},{"title":"Mint Linux安装Docker踩坑指南","url":"/2020/07/11/2020-7-12-mint-install-docker/","content":"我家的服务器选用的Linux Mint系统，最近安装Docker的时候踩了一些小坑，但是总体还算顺利。我们都知道Linux Mint系统是基于Ubuntu的，说实话用起来感觉还是很不错的，安装Docker到Ubuntu的方法几乎可以完全迁移到Mint上。当然，问题就出在这个几乎上。\n首先是正常安装各种依赖：\nsudo apt-get install -y \\    apt-transport-https \\    ca-certificates \\    curl \\    software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-key fingerprint 0EBFCD88\n\n这些都在：https://docs.docker.com/engine/install/ubuntu/可以找到。\n随后是踩坑的：\nsudo add-apt-repository \\    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\    $(lsb_release -cs) \\    stable&quot;\n\nlsb_release -cs查出来是serena，但是这个是Mint的Codename，需要查询对应的Ubuntu的版本：在这里找：https://www.linuxmint.com/download_all.php我们找到是xenial，所以我们就\nsudo add-apt-repository \\    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\    xenial \\    stable&quot;\n\n随后正常安装即可：\nsudo apt-get updatesudo apt-get install docker-cesudo service docker startsudo service docker status\n\n","categories":["技术"],"tags":["Linux"]},{"title":"多线程","url":"/2020/07/14/2020-7-14-Multithreading-leetcode/","content":"1114. 按序打印我们提供了一个类：\npublic class Foo &#123;  public void one() &#123; print(&quot;one&quot;); &#125;  public void two() &#123; print(&quot;two&quot;); &#125;  public void three() &#123; print(&quot;three&quot;); &#125;&#125;\n\n\n三个不同的线程将会共用一个 Foo 实例。\n\n线程 A 将会调用 one() 方法\n\n线程 B 将会调用 two() 方法\n\n线程 C 将会调用 three() 方法\n\n\n请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。\n示例 1:\n输入: [1,2,3]输出: &quot;onetwothree&quot;解释: 有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。正确的输出是 &quot;onetwothree&quot;。\n\n\n示例 2:\n输入: [1,3,2]输出: &quot;onetwothree&quot;解释: 输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。正确的输出是 &quot;onetwothree&quot;。\n\n注意:\n尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。\n你看到的输入格式主要是为了确保测试的全面性。\nclass Foo &#123;    private Semaphore two = new Semaphore(0);    private Semaphore three = new Semaphore(0);    public Foo() &#123;    &#125;    public void first(Runnable printFirst) throws InterruptedException &#123;        // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.        printFirst.run();        two.release();    &#125;    public void second(Runnable printSecond) throws InterruptedException &#123;        two.acquire();        // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.        printSecond.run();        three.release();    &#125;    public void third(Runnable printThird) throws InterruptedException &#123;        three.acquire();        // printThird.run() outputs &quot;third&quot;. Do not change or remove this line.        printThird.run();    &#125;&#125;\n\n","categories":["技术"],"tags":["LeetCode"]},{"title":"设计模式 -- 工厂模式","url":"/2020/07/02/2020-7-2-design-patterns/","content":"什么是工厂模式 ？工厂模式（Factory Pattern）的意义就跟它的名字一样，在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂模式根据不同的参数来实现不同的分配方案和创建对象。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。例如用工厂来创建 人 这个对象，如果我们需要一个男人对象，工厂就会为我们创建一个男人；如果我们需要一个女人，工厂就会为我们生产一个女人。\n工厂模式通常分为：\n\n普通工厂模式\n多个工厂方法模式\n静态工厂方法模式\n\n普通工厂模式刚刚我们说到，用工厂模式来创建人。先创建一个男人，他每天都“吃饭、睡觉、打豆豆”，然后我们再创建一个女人，她每天也“吃饭、睡觉、打豆豆”。\n我们以普通工厂模式为例，新建一个FactoryTest.java。\n\n代码如下：\n// 二者共同的接口interface Human&#123;    public void eat();    public void sleep();    public void beat();&#125;// 创建实现类 Maleclass Male implements Human&#123;    public void eat()&#123;        System.out.println(&quot;Male can eat.&quot;);    &#125;    public void sleep()&#123;        System.out.println(&quot;Male can sleep.&quot;);    &#125;    public void beat()&#123;        System.out.println(&quot;Male can beat.&quot;);    &#125;&#125;//创建实现类 Femaleclass Female implements Human&#123;    public void eat()&#123;        System.out.println(&quot;Female can eat.&quot;);    &#125;    public void sleep()&#123;        System.out.println(&quot;Female can sleep.&quot;);    &#125;    public void beat()&#123;        System.out.println(&quot;Female can beat.&quot;);    &#125;&#125;// 创建普通工厂类class HumanFactory&#123;    public Human createHuman(String gender)&#123;        if( gender.equals(&quot;male&quot;) )&#123;           return new Male();        &#125;else if( gender.equals(&quot;female&quot;))&#123;           return new Female();        &#125;else &#123;            System.out.println(&quot;请输入正确的类型！&quot;);            return null;        &#125;    &#125;&#125;// 工厂测试类public class FactoryTest &#123;    public static void main(String[] args)&#123;        HumanFactory factory = new HumanFactory();        Human male = factory.createHuman(&quot;male&quot;);        male.eat();        male.sleep();        male.beat();    &#125;&#125;\n\n多个工厂方法模式普通工厂模式就是上面那样子了，那么多个工厂方法模式又有什么不同呢？在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象。多个工厂方法模式是提供多个工厂方法，分别创建对象。\n部分示例代码，其他与上面普通工厂模式示例代码一样：\n// 多个工厂方法public class HumanFactory&#123;    public Male createMale() &#123;        return new Male();    &#125;    public Female createFemale() &#123;        return new Female();    &#125;&#125;// 工厂测试类public class FactoryTest &#123;    public static void main(String[] args)&#123;        HumanFactory factory = new HumanFactory();        Human male = factory.createMale();        male.eat();        male.sleep();        male.beat();    &#125;&#125;\n\n静态工厂方法模式将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。\n部分示例代码：\n// 多个工厂方法public class HumanFactory&#123;    public static Male createMale() &#123;        return new Male();    &#125;    public static Female createFemale() &#123;        return new Female();    &#125;&#125;// 工厂测试类public class FactoryTest &#123;    public static void main(String[] args)&#123;        Human male = HumanFactory.createMale();        male.eat();        male.sleep();        male.beat();    &#125;&#125;\n\n\n 总结：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。\n\n","categories":["技术"],"tags":["Java设计模式"]},{"title":"Java并发编程的艺术读后总结（四）","url":"/2020/07/02/2020-7-2-the-art-of-java-concurrency-programming/","content":"Java 并发编程技术线程简介什么是线程\n进程：现代操作系统运行一个程序时，会为其创建一个进程。（进程可以认为是运行着的程序，活着的程序）。\n\n线程：现代操作系统的最新调度单位就是线程，线程也称为轻量级进程（Light Weight Process）。一个进程中可以包含多个线程，这些线程有自己的计数器、堆栈、和局部变量属性，并且能够访问共享的内存变量。\n\n\n为什么要使用多线程使用多线程的原因主要有：\n\n更多的处理器核心\n一个线程在同一时刻只能运行在一个处理器上，将逻辑分配到多个核心处理器上更加有效率。\n\n\n更快的响应时间\n将数据一致性不强的操作分派给其他线程，使响应用户请求的线程尽快完成，缩短响应时间。\n\n\n更好的编程模型\n\n线程的优先级在 Java 线程中， 通过一个整型成员变量 priority 来控制优先级，优先级的范围以 1~10 ，在线程构建的时候可以通过 setPriority(int) 方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。\n\n线程的优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会 Java 线程对于优先级的设定。\n\n线程的状态Java 线程在运行的生命周期中可能处于下表所示的 6 种不同的状态，在某一时刻，线程只能处于其中一个状态。\n\n\nDaemon 线程Daemon线程是一种支持性线程，主要是用在后台程序做一些后台调度与支持性工作。这意味着当JVM中没有非Daemon线程时，JVM将自动退出。\n可以通过调用Thread.setDaemon(true)方法将线程设为Daemon线程。（注：该方法必须在start()或者run()方法前执行，也就是说必须在线程启动前执行）\nDaemon线程被用作，完成支持性工作，但是在java虚拟机退出时，Daemon线程中的finally块并不一定会执行。\n\n 注：在构建Daemon时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。\n\n启动和终止线程构造线程线程运行前需要先构造一个线程，下面是java.lang.Thread中对线程进行初始化的部分。\n　　\n　　从这里也能看到父线程与子线程的关系：\n　　父线程就是当前线程（开启多线程的线程），子线程会具有与父线程一致的优先级， 守护线程，线程组，还会有父线程的可继承ThreadLocal。还会分配给一个唯一的ID。\n　　init()运行完毕，线程对象就初始化好了，在堆内存中等待运行。\n启动线程线程完成初始化后，调用start()方法就可以启动这个线程，线程start()的含义：当前线程同步告知JVM，只要线程规划器空闲，应立即启动调用start()方法的线程。\n理解中断中断：一个标识位属性，通过调用线程的interrupt()方法使其进入中断状态。\n线程可以通过检查自身是否被中断来进行响应。\n线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断进行复位。\n过期的 suspend()、resume() 和 stop()suspend()用于暂停线程、resume()用于恢复线程、stop()用于停止线程，这三个方法都过期了。\n\n 原因：suspend()会导致线程占用资源进入休眠状态，容易导致死锁。stop()不能保证线程资源的正确释放，一旦调用直接结束，可能会导致程序运行在不确定的状态。暂停恢复方法可以用后面的等待&#x2F;通知机制完成。\n\n线程间的通信volatile 和 synchronized 关键字关键字volatile可以修饰字段（成员变量），就是告知程序，任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。\n\n注：过多地使用volatile是不必要的，因为它会降低程序执行的效率。（每一个线程都有自己的内存区域，从自己的内存区域对值操作肯定最快的，使用了volatile的话就会对共享内存进行操作，相比之下自然速率就慢了）\n\n关键字synchronized：修饰代码块、方法、静态方法。实质上是对一个对象的监视器（monitor）的获取，而且这个获取过程是排他的，也就是说同一时刻只有一个线程获取由synchronized所保护对象的监视器。任何对象都有自己的监视器，当对象由同步块或者对象的同步方法调用时，执行方法的线程必须先获取对象的监视器才能进入同步块或者同步方法，而没有获取监视器的线程会阻塞在同步块与同步方法的入口，进入BLOCKED状态。\n\n等待通知机制\n","categories":["技术"],"tags":["并发编程"]},{"title":"个人总结 -- Java基础查漏补缺","url":"/2020/07/03/2020-7-3-summary-java/","content":"1. Java 和 C++ 的区别？\n都是面向对象的语言，都支持封装、继承和多态\nJava 不提供指针来直接访问内存，程序内存更加安全\nJava 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\nJava 有自动内存管理机制，不需要程序员手动释放无用内存\n在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束。但是，Java 语言中没有结束符这一概念。\n\n2. 什么是反射机制反射机制是 Java 语言中一个非常重要的特性，它允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。\n反射机制提供的功能主要有：\n\n得到一个对象所属的类；\n获得一个类的所有成员变量和方法；\n在运行时创建对象；\n在运行时调用对象方法；\n\n3. String、StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。\n\n补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value;\n\n而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\n线程安全性\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n性能\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n对于三者使用的总结：\n\n操作少量的数据: 适用 String\n单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder\n多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer\n\n4. 接口和抽象类的区别？\n接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。\n一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。\n接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。\n从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\n\n5. 为什么有些 Java 接口中没有任何方法在 Java 语言中，有些接口内部没有声明任何方法，也就是说，实现这些接口的类不需要重写任何方法，这些没有任何方法声明的接口又被叫做标识接口，标识接口对实现它的类没有任何语义上的要求，它仅仅充当一个标识的作用用来表明它的类属于一个特定的类型。\n6. 如何实现类似于 C 语言中函数指针的功能？在 Java 中没有指针的概念，那么如果要实现类似于 C 语言中函数指针的功能，可以利用接口和类来实现同样的效果。具体来说，就是先定一个接口，然后在接口中声明要调用的方法，接着实现这个接口，最后把这个实现类的一个对象作为参数传递给调用的程序，调用程序通过这个参数来调用指定的函数，从而实现回调函数的功能。\n7. Java 面向对象编程的三大特性：封装、继承和多态\n封装\n\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\n\n\n继承\n\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。\n\n\n多态\n\n所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。\n\n\n\n8. Java 中提供了哪两种用于多态的机制编译时多态和运行时多态。编译时多态是通过方法的重载实现的，运行时多态使用过方法的覆盖实现的。\n9. this 与 super 有什么区别？在 Java 中，this 用来指向当前实例对象；super 可以用来访问父类的方法或成员变量。\n10. final、finally 和 finalize 有什么区别？\nfinal用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承（不能再派生出新的子类）。\nfinally作为异常处理的一部分，它只能用在try&#x2F;catch语句中，并且附带一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。\nfinalize是Object类的一个方法，在垃圾回收器执行时会调用被回收对象的finalize（）方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件等。需要注意的是，一旦垃圾回收器准备好释放对象占用的空间，将首先调用其finalize（）方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。\n\n11. strictfp 有什么作用？strictfp 可以保证浮点数运算的精确性，而且在不同的硬件平台上会有一致的运行结果。\n关键字 strictfp 是 strict float point 的缩写，指的是精确浮点，它用来确保浮点数运算的准确性。JVM在执行浮点数运算时，如果没有指定 strictfp 关键字，此时计算结果可能会不精确，而且计算结果在不同平台或厂商的虚拟机上会有不同的结果，导致意想不到的错误。而一旦使用了 strictfp 来声明一个类、接口或者方法，那么在所声明的范围内，Java 编译器以及运行环境会完全依照 IEEE 二进制浮点数算术标准（IEEE 754）来执行，在这个关键字声明的范围内所有浮点数的计算都是精确的。\n12. char 型变量中是否可以储存一个中文汉字？在 Java 语言中，默认使用 Unicode 编码方式，即每个字符占用两个字节，因此可以用来储存中文。\n13. “&#x3D;&#x3D;”、equals 和 hashCode 有什么区别？\n“&#x3D;&#x3D;”运算符用来比较两个变量的值是否相等（比较的是引用）。也就是说，该运算符用于比较变量对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能使用“&#x3D;&#x3D;”运算符。\nequals是 Object 类提供的方法之一。每一个 Java 类都继承自 Object 类，所以每一个对象都具有 equals 这个方法。Object 类中定义的 equals（Object）方法是直接使用 “&#x3D;&#x3D;” 运算符比较的两个对象，所以在没有覆盖 equals（Object）方法的情况下，equals（Object）与“&#x3D;&#x3D;”运算符一样，比较的是引用。\nhashCode() 方法是从 Object 类中继承过来的，它也用来鉴定两个对象是否相等。Object类中的 hashCode() 方法返回对象在内存中地址转换成的一个 int 值，所以如果没有重写 hash-Code() 方法，任何对象的 hashCode() 方法都是不相等的。\n\n14. 异常处理的原理是什么？异常是指程序运行时（非编译时）所发生的非正常情况或错误，当程序违反了语义规则时，JVM就会将出现的错误表示为一个异常并抛出。这个异常可以在 catch 程序块中进行捕获然后处理。而异常处理的目的是为了提高程序的安全性和鲁棒性。\n15. Java Socket 是什么？网络上的两个程序通过一个双向的通信连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 也称为套接字，可以用来实现不同虚拟机或不同计算机之间的通信。\n16. BIO, NIO, AIO 有什么区别?\nBIO (Blocking I&#x2F;O): 同步阻塞 I&#x2F;O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。\nNIO (Non-blocking&#x2F;New I&#x2F;O): NIO 是一种同步非阻塞的 I&#x2F;O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I&#x2F;O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I&#x2F;O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发\nAIO (Asynchronous I&#x2F;O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。\n\n","categories":["技术"],"tags":["Java"]},{"title":"Docker","url":"/2020/07/04/2020-7-4-docker-commands/","content":"Docker run 命令docker run：创建一个新的容器并运行一个命令。\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n\nOPTIONS说明：\n\n-a stdin: 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n–name&#x3D;”nginx-lb”: 为容器指定一个名称；\n–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n-h “mars”: 指定容器的hostname；\n-e username&#x3D;”ritchie”: 设置环境变量；\n–env-file&#x3D;[]: 从指定文件读入环境变量；\n–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”: 绑定容器到指定CPU运行；\n**-m :**设置容器使用内存最大值；\n–net&#x3D;”bridge”: 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；\n–link&#x3D;[]: 添加链接到另一个容器；\n–expose&#x3D;[]: 开放一个端口或一组端口；\n–volume , -v: 绑定一个卷\n\nDocker start&#x2F;stop&#x2F;restart 命令docker start :启动一个或多个已经被停止的容器\ndocker stop :停止一个运行中的容器\ndocker restart :重启容器\n语法\ndocker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...]\n\nDocker kill 命令docker kill :杀掉一个运行中的容器。\n语法\ndocker kill [OPTIONS] CONTAINER [CONTAINER...]\n\nDocker rm 命令docker rm ：删除一个或多个容器。\n语法\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\n\nOPTIONS说明：\n\n**-f :**通过 SIGKILL 信号强制删除一个运行中的容器。\n**-l :**移除容器间的网络连接，而非容器本身。\n**-v :**删除与容器关联的卷。\n\nDocker pause&#x2F;unpausedocker pause :暂停容器中所有的进程。\ndocker unpause :恢复容器中所有的进程。\n语法\ndocker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...]\n\nDocker create 命令docker create ：创建一个新的容器但不启动它。\n语法\ndocker create [OPTIONS] IMAGE [COMMAND] [ARG...]\n\nDocker exec 命令docker exec ：在运行的容器中执行命令\n语法\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n\n(…………………………)\n","categories":["技术"],"tags":["Docker"]},{"title":"个人总结 -- 并发查漏补缺","url":"/2020/07/03/2020-7-4-summary-jvm/","content":"Java 内存区域与内存溢出异常\n运行时数据区域程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\nJava虚拟机栈\n栈帧\n每个方法被执行的时候，Java 虚拟就都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。\n\n\n局部变量表\n局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。\n\n\n在《 Java 虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果 Java 虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常。\n\n本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\nJava 堆Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。\n方法区Java 方法区是被所有线程共享的一块内存区域。存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。\n如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。\n运行时常量池运行时常量池 是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\n直接内存HotSpot 虚拟机对象探秘对象创建\n分配内存\n指针碰撞\n空闲列表\n\n\n线程安全\n加锁同步\n本地线程分配缓存\n\n\n\n对象的内存布局在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n\n对象头 （Header）\n是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。\n另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。\n\n\n实例数据（Instance Data）\n对齐填充（Padding）\n\n对象的访问定位主流的访问方式主要有使用句柄和直接指针两种：\n\n如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。\n垃圾收集器与内存分配策略对象已死引用计数法可达性分析法可达性分析法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n垃圾收集算法标记 - 清除算法标记 - 复制算法标记 - 整理算法分代收集算法根据分代的不同选择不同的垃圾收集算法\n垃圾收集器Serial 收集器\n最基本，发展最悠久的；\n单线程工作的收集器；（它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。）\n简单高效\n\nParNew 收集器ParNew收集器实质上是Serial收集器的多线程并行版本\nParallel Scavenge 收集器\n基于标记 - 复制算法\n多线程收集器\n可控制的吞吐量\n\nParallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。\nParallel Old 收集器Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记 - 真理算法实现。\nCMS 收集器 （Concurrent Mark Sweep）工作过程：\n\n初始标记\n并发标记\n重新标记\n并发标记\n\n明显缺点：\n\n对处理器资源非常敏感。\n无法处理浮动垃圾，有可能出现 “ Concurrent Model Failuer” 失败进而道义另一次完全的 ”Stop The World“ 的 Full GC 的产生。\n大量空间碎片。CMS 是一款基于 ”标记 - 清除“ 算法实现的收集器。\n\nGarbage First 收集器G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象。\n 优势：\n\n并行与并发\n分代收集\n空间整合\n可预测的停顿\n\n工作过程：\n\n初始标记\n并发标记\n最终标记\n筛选挥手\n\n内存分配策略\n优先分配 eden\n大对象直接分配到老年代\n长期存活的对象分配到老年代\n空间分配担保\n动态对象年龄判断\n\n逃逸分析与栈上分配 逃逸分析：就是分析出对象的作用域。当一个对象在方法体内声明后，该对象的引用被其他外部所引用时该对象就发生了逃逸，反之就会在栈帧中为对象分配内存空间。\n栈上分配：主要是指在Java程序的执行过程中，在方法体中声明的变量以及创建的对象，将直接从该线程所使用的栈中分配空间。 一般而言，创建对象都是从堆中来分配的，这里是指在栈上来分配空间给新创建的对象。\n虚拟机性能监控、故障处理工具jps作用：用于查看虚拟机运行了那些进程，并输出这些进程LVMID，即进程id，它是使用最频繁的一个命令，因为其它工具需要依赖jps。首先需要jps输出jvm正在运行的的进程id；然后其它工具根据进程id进行监控对应的进程运行情况。\njmap作用：内存映像工具，可用生成堆内存转存快照dump，它还可以查询finalize执行队列，java堆和永久代的详细信息，例如：空间利用率，当前用的是那种收集器等。\njstat作用：用于jvm虚拟机统计信息监控的，主要用于监控jvm内存使用率。\njinfo作用：实时查看java配置信息工具，它也可以实时调整虚拟机各项配置参数的值。\njConsoleVisualVM类文件结构平台无关性Java虚拟机不和包括Java在内的任何语言绑定 它只与“Class文件”这种特定的二进制文件格式所关联 Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息 基于安全方面的考虑 Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束 但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。\nClass 类文件的结构Class文件是一组以8位字节为基础单位的二进制流 各个数据项目严格按照顺序紧凑地排列在Class文件之中 中间没有添加任何分隔符 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据 没有空隙存在 当遇到需要占用8位字节以上空间的数据项时 则会按照高位在前的方式分割成若干个8位字节进行存储\n魔数与 Class 文件的版本每个Class文件的头4个字节称为魔数（Magic Number） 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。\n常量池紧接着主次版本号之后的是常量池入口 常量池可以理解为Class文件之中的资源仓库 它是Class文件结构中与其他项目关联最多的数据类型 也是占用Class文件空间最大的数据项目之一 同时它还是在Class文件中第一个出现的表类型数据项目。\n访问标志在常量池结束之后 紧接着的两个字节代表访问标志（access_flags） 这个标志用于识别一些类或者接口层次的访问信息 包括：这个Class是类还是接口 是否定义为public类型 是否定义为abstract类型 如果是类的话 是否被声明为final等。\n类索引、父类索引与接口索引集合类索引（this_class）和父类索引（super_class）都是一个u2类型的数据 而接口索引集合（interfaces）是一组u2类型的数据的集合 Class文件中由这三项数据来确定这个类的继承关系\n字段表集合字段表（field_info）用于描述接口或者类中声明的变量 字段（field）包括类级变量以及实例级变量 但不包括在方法内部声明的局部变量\n方法表集合Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式 方法表的结构如同字段表一样 依次包括了访问标志（access_flags） 名称索引（name_index） 描述符索引（descriptor_index） 属性表集合（attributes）几项\n属性表集合在Class文件 字段表 方法表都可以携带自己的属性表集合 以用于描述某些场景专有的信息\n\nCode属性Java程序方法体中的代码经过Javac编译器处理后 最终变为字节码指令存储在Code属性内\nExceptions属性Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons） 也就是方法描述时在throws关键字后面列举的异常\nLineNumberTable属性LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系\nLocalVariableTable属性LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系\nSourceFile属性SourceFile属性用于记录生成这个Class文件的源码文件名称\nConstantValue属性ConstantValue属性的作用是通知虚拟机自动为静态变量赋值 只有被static关键字修饰的变量（类变量）才可以使用这项属性\nInnerClasses属性InnerClasses属性用于记录内部类与宿主类之间的关联 如果一个类中定义了内部类 那编译器将会为它以及它所包含的内部类生成InnerClasses属性\nDeprecated及Synthetic属性Deprecated和Synthetic两个属性都属于标志类型的布尔属性 只存在有和没有的区别 没有属性值的概念Deprecated属性用于表示某个类 字段或者方法 已经被程序作者定为不再推荐使用 它可以通过在代码中使用@deprecated注释进行设置Synthetic属性代表此字段或者方法并不是由Java源码直接产生的 而是由编译器自行添加的\nStackMapTable属性这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用 目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器\nSignature属性任何类 接口 初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types） 则Signature属性会为它记录泛型签名信息\nBootstrapMethods属性这个属性用于保存invokedynamic指令引用的引导方法限定符\n\n字节码指令简介Java虚拟机的指令由一个字节长度的 代表着某种特定操作含义的数字（称为操作码 Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数 Operands）而构成 由于Java虚拟机采用面向操作数栈而不是寄存器的架构 所以大多数的指令都不包含操作数 只有一个操作码\n字节码与数据类型在Java虚拟机的指令集中 大多数的指令都包含了其操作所对应的数据类型信息 例如 iload指令用于从局部变量表中加载int型的数据到操作数栈中 而fload指令加载的则是float类型的数据 这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的 但在Class文件中它们必须拥有各自独立的操作码\n加载和存储指令\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输\n运算指令\n运算或算术指令用于对两个操作数栈上的值进行某种特定运算 并把结果重新存入到操作栈顶\n类型转换指令\n类型转换指令可以将两种不同的数值类型进行相互转换 这些转换操作一般用于实现用户代码中的显式类型转换操作 或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题\n对象创建与访问指令\n虽然类实例和数组都是对象 但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令 对象创建后 就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素\n操作数栈管理指令\n如同操作一个普通数据结构中的堆栈那样 Java虚拟机提供了一些用于直接操作操作数栈的指令\n控制转移指令\n控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序 从概念模型上理解 可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值\n方法调用和返回指令invokevirtual指令用于调用对象的实例方法 根据对象的实际类型进行分派（虚方法分派） 这也是Java语言中最常见的方法分派方式invokeinterface指令用于调用接口方法 它会在运行时搜索一个实现了这个接口方法的对象 找出适合的方法进行调用invokespecial指令用于调用一些需要特殊处理的实例方法 包括实例初始化方法 私有方法和父类方法invokestatic指令用于调用类方法（static方法）invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法 并执行该方法 前面4条调用指令的分派逻辑都固化在Java虚拟机内部 而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的\n 异常处理指令在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现 除了用throw语句显式抛出异常情况之外 Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出 而在Java虚拟机中 处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现 现在已经不用了） 而是采用异常表来完成的\n同步指令Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步 这两种同步结构都是使用管程（Monitor）来支持的同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的 Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义 正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持\n公有设计和私有实现Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集 这些内容与硬件 操作系统及具体的Java虚拟机实现之间是完全独立的 虚拟机实现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段虚拟机实现的方式主要有以下两种：将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生成技术）\n虚拟机类加载机制虚拟机把描述类的数据从 Class 文件加载到内存， 并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型， 这就是虚拟机的类加载机制。\n重点JDK 提供的并发容器总结JDK 提供的这些容器大部分在 java.util.concurrent 包中。\n\nConcurrentHashMap: 线程安全的 HashMap\nCopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.\nConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。\nBlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。\nConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。\n\nConcurrentHashMap 和 HashMap 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n\n底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n实现线程安全的方式（重要）： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n何谓悲观锁与乐观锁\n乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。\n\n悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\n乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。\n两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。\n乐观锁常见的两种实现方式\n乐观锁一般会使用版本号机制或CAS算法实现。\n\n（………………………………………………）\n","categories":["技术"],"tags":["Java"]},{"title":"第 196 场周赛","url":"/2020/07/05/2020-7-5-leetcode-weekly-contest-196/","content":"5452. 判断能否形成等差数列class Solution &#123;    public boolean canMakeArithmeticProgression(int[] arr) &#123;        Arrays.sort(arr);        if(arr.length==1)            return true;        int c=arr[1]-arr[0];        for(int i=1;i&lt;arr.length-1;i++) &#123;            if(arr[i+1]-arr[i]!=c)                return false;        &#125;        return true;    &#125;&#125;\n\n5453. 所有蚂蚁掉下来前的最后一刻class Solution &#123;    public int getLastMoment(int n, int[] left, int[] right) &#123;        int max=0;\t\tfor(int i=0;i&lt;right.length; i++) &#123;\t\t\tint max_t = n-right[i];\t\t\tmax = Math.max(max, max_t);\t\t&#125;\t\tfor(int i=0;i&lt;left.length; i++) &#123;\t\t\tint max_t = left[i];\t\t\tmax = Math.max(max, max_t);\t\t&#125;\t\treturn max;    &#125;&#125;\n\n5454. 统计全 1 子矩阵解题思路矩阵里每个点(i.j)统计他这行左边到他这个位置最多有几个连续的1，存为left[i][j]。然后对于每个点(i.j)，我们固定子矩形的右下角为(i.j)，利用left从该行i向上寻找子矩阵左上角为第k行的矩阵个数。每次将子矩阵个数加到答案中即可。时间复杂度O(nnm)，空间复杂度O(nm)。\nclass Solution &#123;public:    int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;        int n = mat.size();        int m = mat[0].size();        vector&lt;vector&lt;int&gt; &gt; left(n,vector&lt;int&gt;(m));        int now = 0;        for(int i=0;i&lt;n;i++)&#123;            now = 0;            for(int j=0;j&lt;m;j++)&#123;                if(mat[i][j] == 1) now ++;                else now = 0;                left[i][j] = now;            &#125;        &#125;        int ans = 0,minx;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                minx = 0x3f3f3f3f;                for(int k=i;k&gt;=0;k--)&#123;                    minx = min(left[k][j],minx);                    ans += minx;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;作者：lin-miao-miao链接：https://leetcode-cn.com/problems/count-submatrices-with-all-ones/solution/5454-tong-ji-quan-1-zi-ju-xing-by-lin-miao-miao/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":["技术"],"tags":["LeetCode"]},{"title":"Looking forward to interview","url":"/2020/09/20/2020-9-20-Looking-forward-to-interview/","content":"Java 基础\n介绍一下 volatile？\n\nvolatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的 代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的， 这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效 率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有 happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面 对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模 型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做 了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。 加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。 Lock指令对Intel 平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多 核之间数据不一致性问题。\n\n\n锁有了解吗？ 说一下 Synchronized 和 lock\n\nsynchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证 在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁， 偏向锁来有优化关键字的性能。Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现； synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行， 使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没 有成功获取锁，而 synchronized 却无法办到。\n\n\nJava 里面的 final 关键字的作用\n\n当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以更具需要设定为 final，但是要注意 final 类中的所有成员方法都会被隐式的指定为final方法。\n对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后就不能再被改变；如果是引用类型变量，则在对其初始化之后便不能再让其指向另一个对象。\n\n\nJava 有哪些特性，举个多态的例子。\n\n封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据 发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）\n\n\nString 为啥不可变？\n\n不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不 能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对 象，引用类型指向的对象的状态也不能改变。String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字 节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以 在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串 是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得 数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不 可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安 全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享， 这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的 所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计 算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。\n\n\n请列举你所知道的 Object 类的方法\n\nObject()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指 示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引 用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回 该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此 对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等 待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导 致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超 过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此 对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某 个实际时间量。\n\n\nStringBuffer 和 StringBuilder 有什么区别？底层区别？\n\nStringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其 实就是比 StringBuilder 多了 Synchronized 修饰符。\n\n\n类加载机制，双亲委派模型，好处是什么？\n\n双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次 关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最 终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各 种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的 话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。\n\n\n解释 extends 和 super 泛型限定符-上界不存下界不取\n\n\n上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确 定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类， 不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把 所有的子类向上转型为 Fruit。\n下界 &lt;? super Apple&gt;， 表示Apple的所有父类，包括Fruit， 一直可以追溯到老祖宗Object 。 那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父 类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple 及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接 着呢，除了 Object，其他的都接不住。\n\n\n\n谈谈如何通过反射创建对象？\n\n\n方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance()\n方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器 （Constructor）对象并调用其 newInstance()方法创建对象，例如： String.class.getConstructor(String.class).newInstance(“Hello”);\n\n\n\nhashMap 内部具体如何实现的？\n\nHashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当 前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链 式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编 号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是， HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转 换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长 度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4， 这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为 树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频 繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构 转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发 生树转链表、链表转树，效率会很低。\n\n\n如果 hashMap 的 key 是一个自定义的类，怎么办？\n\n使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。\n\n\nConcurrenthashmap 有什么优势， 1.7， 1.8 区别？\n\nConcurrenthashmap 线程安全的， 1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进 行实现的， lock 加在 Segment 上面。 1.7size 计算是先采用不加锁的方式，连续计算元素的个数， 最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果 前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来 保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当 插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和 CounterCell 数组中的数量，即可得到元素的总个数；\n\n\n线程池运行流程，参数，策略\n\n线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线 程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列 满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝 策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。\n\n\nJava 中有常用的几种线程池\n\n1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一 个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个 工作线程。3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程 来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特 色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个 线程是活动的 。4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执 行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)\n\n\n概括的解释下线程的几种可用状态。\n\n\n新建( new )：新创建了一个线程对象。 \n\n可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 \n\n运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ， 执行程序代码。\n\n阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。\n\n 阻塞的情况分三种：\n(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待 队列( waitting queue )中。 \n(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用， 则 JVM 会把该线程放入锁池( lock pool )中。\n(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join () 方法，或者发出了 I &#x2F; O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、join ()等待线程终止或者超时、或者 I &#x2F; O 处理完毕时，线程重新转入可运行( runnable )状态。\n\n\n死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则 该线程结束生命周期。死亡的线程不可再次复生。\n\n\n\n\n讲一下非公平锁和公平锁在 reetrantlock 里的实现。\n\n如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公 平锁，只要 CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是 否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取 并释放锁之后才能继续获取锁。\n\n\n\n","categories":["技术"],"tags":["Java"]},{"title":"面试 Spring 问题（无解答）","url":"/2020/09/24/2020-9-24-Spring/","content":"Spring\n使用 Spring 有什么好处？\nSpring 依赖注入方式？\n@Resource 默认装配方式\nBean 的作用域\n如何配置 Bean\n@Autowire\nSpring 支持的事务管理方式\nSpring 事务传播行为\n@RequestMapping\nSpring 前后端传值方式\n@Controller 和 @ RestController\n\n","categories":["技术"],"tags":["Spring Interview"]},{"title":"python-auto-dependencies","url":"/2021/01/08/2021-01-8-python-auto-dependencies/","content":"Python 自动生成当前项目依赖包文件\n方法一\n# cd 到项目路径下，执行以下命令pip freeze &gt; requirements.txt\n\n方法二\n使用工具 pipreqs\n# 1 安装 pipreqspip install pipreqs# 2 cd 到项目路径下，执行以下命令pipreqs ./\n\n使用 requests.txt 自动安装所有依赖包\npip install -r requirements.txt","categories":["技术"],"tags":["python"]},{"title":"iOS 提示框","url":"/2021/07/09/2021-07-09-iOS-uialertcontroller/","content":"iOS 中弹出一个提示框//要显示的信息NSString *message = [[NSString alloc] initWithFormat:@&quot;message&quot;,(long)indexPath.section,(long)indexPath.row];//初始化并设置一个 title 和 messageUIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;title&quot; message:message preferredStyle:UIAlertControllerStyleAlert];//设置一个按钮并指定按钮的 title 和处理函数。[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;    //点击确定后执行的操作；      NSLog(@&quot;你点击了确定&quot;);  &#125;]];  [self presentViewController:alert animated:true completion:^&#123;    //显示提示框后执行的事件；      NSLog(@&quot;此时出现提示&quot;);        &#125;];\n\n","categories":["技术"],"tags":["iOS"]},{"title":"SpringSecurity 动态加载用户角色列表","url":"/2021/07/17/2021-07-17-SpringSecurity-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E5%88%97%E8%A1%A8/","content":"SpringSecurity 动态加载用户角色列表通过实现 AccessDecisionManager 接口和 FilterInvocationSecurityMetadataSource 接口\n\n实现 AccessDecisionManager 接口\n\n@Componentpublic class CustomAccessDecisionManager implements AccessDecisionManager &#123;    @Override    public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException &#123;        for(ConfigAttribute configAttribute : collection) &#123;            //如果你请求的url在数据库中不具备角色，即不存在限制            if(&quot;ROLE_def&quot;.equals(configAttribute.getAttribute())) &#123;                //匿名用户拒绝访问                if(authentication instanceof AnonymousAuthenticationToken) &#123;                    throw new AccessDeniedException(&quot;权限不足，无法访问&quot;);                &#125; else &#123;                    //登录用户放行                    return;                &#125;            &#125;            //如果你访问的路径在数据库中存在角色            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            for (GrantedAuthority authority : authorities) &#123;                //查看用户是否拥有该权限,如果有则直接放行                if(authority.getAuthority().equals(configAttribute.getAttribute()))                    return;            &#125;        &#125;        //登录却没有相应权限        throw new AccessDeniedException(&quot;权限不足，无法访问&quot;);    &#125;    @Override    public boolean supports(ConfigAttribute configAttribute) &#123;        return true;    &#125;    @Override    public boolean supports(Class&lt;?&gt; aClass) &#123;        return true;    &#125;&#125;\n\n\n实现 AccessDecisionManager 接口\n\n@Componentpublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123;    private AntPathMatcher antPathMatcher = new AntPathMatcher();    private UserRoleService userRoleService;    @Autowired    public CustomFilterInvocationSecurityMetadataSource(UserRoleService userRoleService) &#123;        this.userRoleService = userRoleService;    &#125;    @Override    public Collection&lt;ConfigAttribute&gt; getAttributes(Object obj) throws IllegalArgumentException &#123;        //获取当前用户请求的url        String requestUrl = ((FilterInvocation) obj).getRequestUrl();        //数据库中查询出所有路径        List&lt;Role&gt; roleList = userRoleService.getAllRole();        List&lt;String&gt; roles = new ArrayList&lt;&gt;();        for(Role role : roleList) &#123;            if(antPathMatcher.match(role.getPath(),requestUrl)) &#123;                roles.add(role.getName());            &#125;        &#125;        String[] roleStr = new String[roles.size()];        roles.toArray(roleStr);        if(roles.size() != 0)            return SecurityConfig.createList(roleStr);        else            return SecurityConfig.createList(&quot;ROLE_def&quot;);    &#125;    @Override    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;        return null;    &#125;    @Override    public boolean supports(Class&lt;?&gt; aClass) &#123;        return true;    &#125;&#125;\n\n\n配置Spring Security\n\nhttp         //动态获取角色权限         .authorizeRequests()         .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;             @Override             public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O obj) &#123;                 obj.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                 obj.setAccessDecisionManager(customAccessDecisionManager);                 return obj;             &#125;         &#125;)\n\n\n\n","categories":["技术"],"tags":["SpringSecurity"]},{"title":"Spring Security JWT(Json Web Token) 登录实现","url":"/2021/07/20/2021-07-20-Spring-Security-JWT/","content":"Spring Security JWT(Json Web Token) 登录实现使用 Spring Security 实现 JWT 登录，我们只需要在 Spring Security 的众多 Filter 中添加一个我们用于 JWT 登录的 Filter，以下是一个demo\n// JwtAuthenticationFilter.javapublic class JwtAuthenticationFilter extends OncePerRequestFilter &#123;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;        String tokenHeader = request.getHeader(JwtTokenUtils.TOKEN_HEADER);        if(null == tokenHeader || !tokenHeader.startsWith(JwtTokenUtils.TOKEN_PREFIX)) &#123;            filterChain.doFilter(request, response);            return;        &#125;        try &#123;            String token = tokenHeader.replace(JwtTokenUtils.TOKEN_PREFIX, &quot;&quot;);            String username = JwtTokenUtils.getUserName(token);            List&lt;Role&gt; roleList = JwtTokenUtils.getUserRole(token);            List&lt;GrantedAuthority&gt; roles = new ArrayList&lt;GrantedAuthority&gt;();            roleList.forEach(item -&gt; &#123;                roles.add(new GrantedAuthority() &#123;                    @Override                    public String getAuthority() &#123;                        return item.getName();                    &#125;                &#125;);            &#125;);            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, null, roles);            SecurityContextHolder.getContext().setAuthentication(authenticationToken);        &#125; catch (Exception e) &#123;            logger.error(&quot;无法验证令牌&quot;);        &#125;        filterChain.doFilter(request, response);    &#125;&#125;\n\n// JwtAuthenticationEntryPoint.java 用来处理认证失败的情况@Componentpublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;    @Override    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;        RestUtil.response(response, SystemCode.AccessTokenError);    &#125;&#125;\n\n// JwtAccessDeniedHandler.java 用来处理权限不足的情况@Componentpublic class JwtAccessDeniedHandler implements AccessDeniedHandler &#123;    @Override    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123;        RestUtil.response(httpServletResponse, SystemCode.AccessDenied);    &#125;&#125;\n\n完成以上，我们只需要把这些配置进 Spring Security 就可以了。\n// SecurityConfig.java @Configuration@EnableWebSecuritypublic class SecurityConfig &#123;    @Configuration    public static class SecurityConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;              @Override        protected void configure(HttpSecurity http) throws Exception &#123;            //网页中允许使用 iframe 打开页面            http.headers().frameOptions().disable();          //关闭 Session， 既然我们使用 JWT 进行鉴权，也就不再需要 Session 保持回话鉴权了，当然此处视情况而定            http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);            http                    .addFilterBefore(new JwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)                    .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).accessDeniedHandler(jwtAccessDeniedHandler)              //跨域限制关闭， 后期可以自己进行设置                    .and().csrf().disable()                    .cors();        &#125;    &#125;&#125;\n\n至此，我们已经完成了 Spring Security 中使用 JWT 的基本操作了。\n","categories":["技术"],"tags":["SpringSecurity"]},{"title":"proxychais 无法代理 ping 命令的原因","url":"/2021/08/05/2021-08-05-proxychais-can-not-proxy-ping/","content":"proxychains无法代理ping命令的原因proxychains支持的是socks、http和https协议，它们是以tcp或者udp为基础的，所以proxychains只支持使用tcp或udp协议的程序。然而ping命令使用的是ICMP协议，自然无法使用。\n","categories":["技术"],"tags":["网络小工具"]},{"title":"python-auto-dependencies","url":"/2021/01/08/2021-1-8-python-auto-dependencies/","content":"Python 自动生成当前项目依赖包文件\n方法一\n# cd 到项目路径下，执行以下命令pip freeze &gt; requirements.txt\n\n方法二\n使用工具 pipreqs\n# 1 安装 pipreqspip install pipreqs# 2 cd 到项目路径下，执行以下命令pipreqs ./\n\n使用 requests.txt 自动安装所有依赖包\npip install -r requirements.txt","categories":["技术"],"tags":["python"]},{"title":"一个通用的 .gitignore","url":"/2021/04/01/2021-4-1-A-generic-.gitignore/","content":"## .gitignore for Grails 1.2 and 1.3# .gitignore for start.spring.iomvnwmvnw.cmdHELP.md.mvntarget/*.releaseBackup# web application files#/web-app/WEB-INF # IDE support files/.classpath/.launch/.project/.settings/*.launch/*.tmproj/ivy*/eclipse # default HSQL database files for production mode/prodDb.* # general HSQL database files*Db.properties*Db.script # logs/stacktrace.log/test/reports/logs*.log*.log.* # project release file/*.war # plugin release file/*.zip/*.zip.sha1 # older plugin install locations/plugins/web-app/plugins/web-app/WEB-INF/classes # &quot;temporary&quot; build filestarget/out/build/ # other*.iws #.gitignore for java*.class # Package Files #*.jar*.war*.ear ## .gitignore for eclipse *.pydevproject.project.metadatabin/**tmp/**tmp/**/**.tmp*.bak*.swp*~.niblocal.properties.classpath.settings/.loadpath # External tool builders.externalToolBuilders/ # Locally stored &quot;Eclipse launch configurations&quot;*.launch # CDT-specific.cproject # PDT-specific.buildpath ## .gitignore for intellij *.iml*.ipr*.iws.idea/ ## .gitignore for linux.*!.gitignore*~ ## .gitignore for windows # Windows image file cachesThumbs.dbehthumbs.db # Folder config fileDesktop.ini # Recycle Bin used on file shares$RECYCLE.BIN/ ## .gitignore for mac os x .DS_Store.AppleDouble.LSOverrideIcon  # Thumbnails._* # Files that might appear on external disk.Spotlight-V100.Trashes## hack for graddle wrapper!wrapper/*.jar!**/wrapper/*.jar\n\n","categories":["技术"],"tags":["Git"]},{"title":"一个通用的 .gitignore","url":"/2021/04/01/2021-4-1-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84-.gitignore/","content":"## .gitignore for Grails 1.2 and 1.3# .gitignore for start.spring.iomvnwmvnw.cmdHELP.md.mvntarget/*.releaseBackup# web application files#/web-app/WEB-INF # IDE support files/.classpath/.launch/.project/.settings/*.launch/*.tmproj/ivy*/eclipse # default HSQL database files for production mode/prodDb.* # general HSQL database files*Db.properties*Db.script # logs/stacktrace.log/test/reports/logs*.log*.log.* # project release file/*.war # plugin release file/*.zip/*.zip.sha1 # older plugin install locations/plugins/web-app/plugins/web-app/WEB-INF/classes # &quot;temporary&quot; build filestarget/out/build/ # other*.iws #.gitignore for java*.class # Package Files #*.jar*.war*.ear ## .gitignore for eclipse *.pydevproject.project.metadatabin/**tmp/**tmp/**/**.tmp*.bak*.swp*~.niblocal.properties.classpath.settings/.loadpath # External tool builders.externalToolBuilders/ # Locally stored &quot;Eclipse launch configurations&quot;*.launch # CDT-specific.cproject # PDT-specific.buildpath ## .gitignore for intellij *.iml*.ipr*.iws.idea/ ## .gitignore for linux.*!.gitignore*~ ## .gitignore for windows # Windows image file cachesThumbs.dbehthumbs.db # Folder config fileDesktop.ini # Recycle Bin used on file shares$RECYCLE.BIN/ ## .gitignore for mac os x .DS_Store.AppleDouble.LSOverrideIcon  # Thumbnails._* # Files that might appear on external disk.Spotlight-V100.Trashes## hack for graddle wrapper!wrapper/*.jar!**/wrapper/*.jar\n\n","categories":["技术"],"tags":["Git"]},{"title":"LaTeX 学习过程","url":"/2021/04/02/2021-4-2-LaTeX-learning-draft/","content":"LaTeX 的 hello word\\documentclass&#123;article&#125;% 这里是导言区\\begin&#123;document&#125;Hello, world!\\end&#123;document&#125;\n\n\n以反斜杠 \\ 开头，以第一个空格或非字母 的字符结束的一串文字成为控制序列（或称命令&#x2F;标记）\n% 是注释\n\n宏包通过/usepackage&#123;&#125;\t可以调用宏包，下面是用 UTF-8 编码， XeLaTeX 编译的代码\n\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125;你好，world!\\end&#123;document&#125;\n\n","categories":["技术"],"tags":["LaTeX"]},{"title":"Mac(M1)安装JDK8启动慢解决方案","url":"/2021/04/02/2021-4-2-Mac-M1-installation-of-JDK8-slow-startup-solution/","content":"系统版本\n\nmacOS Big Sur 11.2.2\nZulu JDK 8\n\n什么问题同样的网络环境，同一个SpringBoot项目\n\n在win10下启动，需要10秒左右\n在ubuntu18.04下启动，需要7秒左右\n在macOS下启动，竟然需要23多秒\n\n解决方案\n\n打开终端输入hostname，查看你的mac的主机名称，把它给复制下来\n\n修改/etc/hosts文件，大家应该都知道这个文件是做什么的\n\n没修改前应该是这个样子\n### Host Database## localhost is used to configure the loopback interface# when the system is booting.  Do not change this entry.##127.0.0.1\tlocalhost255.255.255.255\tbroadcasthost::1\tlocalhost\n\n把它改成这个样子\n### Host Database## localhost is used to configure the loopback interface# when the system is booting.  Do not change this entry.##127.0.0.1\tlocalhost lyxdeMacBook-Pro.local255.255.255.255\tbroadcasthost::1\tlocalhost HandeMacBook-Air.local # &#x27;HandeMacBook-Air.local&#x27;  替换为你的主机名\n\nlyxdeMacBook-Pro.local即是前边复制下的主机名\n\n好了，再运行项目就可以了，2到4秒，终于舒服了\n\n\n只有在 JDK8 才会出现该问题，在 JDK11 正常。\n","categories":["技术"],"tags":["macOS"]},{"title":"MacOS 使用总结","url":"/2021/04/03/2021-4-3-MacOS-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-draft/","content":"访达中显示隐藏文件夹快捷键：commond + shift + .\n修改某类文件的默认打开方式右键文件 -&gt; 显示简介 -&gt;更改打开方式 -&gt; 选择自己想用的app -&gt; 点击全部使用\n","categories":["技术"],"tags":["MacOS"]},{"title":"Upgrading NodeJS causes Sass compilation error","url":"/2021/04/05/2021-4-5-sass-error/","content":"MacOS 更换 NodeJS 后 Sass 报错Syntax Error: Error: Node Sass does not yet support your current environment: OS X Unsupported architecture (arm64) with Unsupported runtime (88)\n\n\n这个错误是我在切换 NodeJS 版本的时候遇到的（从 x86 切换至 arm）\n错误的解释建议阅读此发行信息：https : &#x2F;&#x2F;github.com&#x2F;sass&#x2F;node-sass&#x2F;releases&#x2F;tag&#x2F;v4.5.0。我认为这不是很有用。\n我在论坛上阅读了一些答案，例如删除 node_modules 目录并通过 npm install 重新安装所有节点软件包。不要那样做！如果您在项目的开发阶段，如果 package.json 的软件包版本不干净，您可能会遇到麻烦。\n如何快速简单的修复？我不能解释当我们切换 NodeJS 版本的时候发生了什么，但我知道可以用以下命令修复该错误\nnpm rebuild node-sass\n\n这可能需要一些时间，不用担心。\n","categories":["技术"],"tags":["NodeJS"]},{"title":"tor 的简单配置","url":"/2021/04/07/2021-4-7-tor-simple-configer/","content":"Tor 是什么？Tor（The Onion Router，洋葱路由器）是实现匿名通信的自由软件。Tor是第二代洋葱路由的一种实现，用户通过Tor可以在因特网上进行匿名交流。而对于爬虫爱好者来说，Tor会隐藏你的真实ip地址，导致被爬网站的网管无法封掉你的ip（当然是在对方觉得精确定位你的ip无价值的情况下）安全是相对的，匿名也是相对的。\n安装 Tor如果你用的是 MacOS 并且安装了 Homebrew ，那么你可以通过下面的命令轻松的安装 Tor\nbrew install tor\n\n或者去 https://www.torproject.org/ 寻求其他系统的版本。\n简单配置如果你用 Homebrew 安装完成之后，那么你将在/opt/homebrew/etc/tor路径下找到torrc.sample文件，这是一个 Tor 的配置文件模版，我们需要的是删除 .simple后缀，然后在文件中添加以下内容：\nCookieAuthentication 1# 代理地址为 127.0.0.1:1087# HTTPProxy 127.0.0.1:1087# HTTPSProxy 127.0.0.1:1087Socks5Proxy 127.0.0.1:1086# 外部程序Tor 的端口SocksPort 9050# 自动切换 ip 的时间MaxCircuitDirtiness 10 seconds\n\n运行你可以直接运行Tor命令启动 Tor\n# torApr 07 16:21:16.485 [notice] Tor 0.4.5.7 running on Darwin with Libevent 2.1.12-stable, OpenSSL 1.1.1k, Zlib 1.2.11, Liblzma N/A, Libzstd N/A and Unknown N/A as libc.Apr 07 16:21:16.485 [notice] Tor can&#x27;t help you if you use it wrong! Learn how to be safe at https://www.torproject.org/download/download#warningApr 07 16:21:16.486 [notice] Read configuration file &quot;/opt/homebrew/etc/tor/torrc&quot;.Apr 07 16:21:16.489 [notice] Opening Socks listener on 127.0.0.1:9050Apr 07 16:21:16.490 [notice] Opened Socks listener connection (ready) on 127.0.0.1:9050Apr 07 16:21:16.000 [notice] Parsing GEOIP IPv4 file /opt/homebrew/Cellar/tor/0.4.5.7/share/tor/geoip.Apr 07 16:21:16.000 [notice] Parsing GEOIP IPv6 file /opt/homebrew/Cellar/tor/0.4.5.7/share/tor/geoip6.Apr 07 16:21:16.000 [notice] Bootstrapped 0% (starting): StartingApr 07 16:21:16.000 [notice] Starting with guard context &quot;default&quot;Apr 07 16:21:17.000 [notice] Bootstrapped 3% (conn_proxy): Connecting to proxyApr 07 16:21:17.000 [notice] Bootstrapped 4% (conn_done_proxy): Connected to proxyApr 07 16:21:17.000 [notice] Bootstrapped 10% (conn_done): Connected to a relayApr 07 16:21:18.000 [notice] Bootstrapped 14% (handshake): Handshaking with a relayApr 07 16:21:19.000 [notice] Bootstrapped 15% (handshake_done): Handshake with a relay doneApr 07 16:21:19.000 [notice] Bootstrapped 75% (enough_dirinfo): Loaded enough directory info to build circuitsApr 07 16:21:19.000 [notice] Bootstrapped 90% (ap_handshake_done): Handshake finished with a relay to build circuitsApr 07 16:21:19.000 [notice] Bootstrapped 95% (circuit_create): Establishing a Tor circuitApr 07 16:21:20.000 [notice] Bootstrapped 100% (done): Done\n\nMacOS 中你也可以通过brew services start tor来让 Tor 在后台运行。\n","categories":["技术"],"tags":["Network"]},{"title":"Android Studio Gradle 设置代理","url":"/2021/05/07/2021-6-27-Android-Studio-Gradle-Proxy-Settings/","content":"Android Studio Gradle 设置代理systemProp.http.nonProxyHosts=*.xcompany.com|localhostsystemProp.http.proxyHost=127.0.0.1systemProp.http.proxyPort=1087systemProp.https.nonProxyHosts=*.xcompany.com|localhostsystemProp.https.proxyHost=127.0.0.1systemProp.https.proxyPort=1087\n\n这是AS自动配置的但是在我的 Mac 上只有这个配置是不能用的，需要在grade.properties中加入下面的配置，端口是本地socks5代理端口\norg.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1086 -DsocksNonProxyHosts=*.xcompany.com\n\n\n\n","categories":["技术"],"tags":["Android"]},{"title":"Flutter 插件 sqflite","url":"/2021/07/25/2021-7-25-sqflite/","content":"什么是sqflitesqflite是一个 Flutter 插件。它允许我们通过 flutter 代码存储、检索和操作我们的 sqflite数据库。sqflite支持 Android 和 iOS 平台。\n\nsqflite提供数据库事务和批处理。\nsqflite具有内置的自动版本管理。\nsqflite提供了易于使用的方法来插入、查询、更新以及从数据库中删除数据。\n这些 CRUD 操作在 iOS 和 Android 的后台线程中执行。这可以释放 UI 以保持响应。\n\n安装sqflite\n在pubspec.yaml 中添加\ndependencies:  sqflite: ^0.12.1\n\n然后使用 flutter pub get命令，flutter就会将sqflite安装到你的项目中。\n\n\n基本使用// 获得数据库路径var databasesPath = await getDatabasesPath();String path = join(databasesPath, &#x27;demo.db&#x27;);// 删除数据库await deleteDatabase(path);// 打开数据库Database database = await openDatabase(path, version: 1,    onCreate: (Database db, int version) async &#123;  // 创建数据库的时候创建表  await db.execute(      &#x27;CREATE TABLE Test (id INTEGER PRIMARY KEY, name TEXT, value INTEGER, num REAL)&#x27;);&#125;);// INSERTawait database.transaction((txn) async &#123;  int id1 = await txn.rawInsert(      &#x27;INSERT INTO Test(name, value, num) VALUES(&quot;some name&quot;, 1234, 456.789)&#x27;);  print(&#x27;inserted1: $id1&#x27;);  int id2 = await txn.rawInsert(      &#x27;INSERT INTO Test(name, value, num) VALUES(?, ?, ?)&#x27;,      [&#x27;another name&#x27;, 12345678, 3.1416]);  print(&#x27;inserted2: $id2&#x27;);&#125;);// UPDATEint count = await database.rawUpdate(    &#x27;UPDATE Test SET name = ?, value = ? WHERE name = ?&#x27;,    [&#x27;updated name&#x27;, &#x27;9876&#x27;, &#x27;some name&#x27;]);print(&#x27;updated: $count&#x27;);// SELECTList&lt;Map&gt; list = await database.rawQuery(&#x27;SELECT * FROM Test&#x27;);List&lt;Map&gt; expectedList = [  &#123;&#x27;name&#x27;: &#x27;updated name&#x27;, &#x27;id&#x27;: 1, &#x27;value&#x27;: 9876, &#x27;num&#x27;: 456.789&#125;,  &#123;&#x27;name&#x27;: &#x27;another name&#x27;, &#x27;id&#x27;: 2, &#x27;value&#x27;: 12345678, &#x27;num&#x27;: 3.1416&#125;];print(list);print(expectedList);assert(const DeepCollectionEquality().equals(list, expectedList));// Count the recordscount = Sqflite    .firstIntValue(await database.rawQuery(&#x27;SELECT COUNT(*) FROM Test&#x27;));assert(count == 2);// DELETEcount = await database    .rawDelete(&#x27;DELETE FROM Test WHERE name = ?&#x27;, [&#x27;another name&#x27;]);assert(count == 1);// 关闭数据库await database.close();\n","categories":["技术"],"tags":["Flutter"]},{"title":"Git中reset命令的参数","url":"/2021/07/27/2021-7-27-Git%E4%B8%ADreset%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0/","content":"Git中reset的参数今天使用Git的时候碰到的问题，使用reset命令相关参数不够了解，以下是相关参数介绍：\n（1） 默认的mixed参数：git reset commit_id，将本地版本库的头指针全部重置到指定版本，且会重置暂存区，即这次提交之后的所有变更都移动到未暂存阶段。\n（2） soft 参数：git reset --soft commit_id 意为将版本库软回退到commit_id指定的版本版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。\n（3） hard参数：git reset --hard commit_id 意为将版本库回退commit_id指定的版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本 。\n","categories":["技术"],"tags":["Git"]},{"title":"python3 argparse 可选参数","url":"/2021/07/29/2021-7-29-python-argparse-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0/","content":"argparse 可选参数如何使用argparse的add_argument()函数，以便用户必须解析一个必需的值，也可能解析一个可选值？在\n例如--read book [page]。您可以省略page，也可以解析要阅读的特定页面。\n在调用中添加nargs=&#39;?&#39;，并将值1作为默认值（也可能将type=int解析为数字）：\nparser.add_argument(&#x27; read&#x27;, dest=&#x27;book&#x27;, help=&#x27;book to read&#x27;)parser.add_argument(&#x27;page&#x27;, nargs=&#x27;?&#x27;, default=1, type=int, help=&#x27;page number&#x27;)\n\n","categories":["技术"],"tags":["python"]},{"title":"Foundation Framework","url":"/2021/07/07/2021-7-3-foundation%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","content":"NSArray//创建一个 NSArrayNSArray *colors = @[@&quot;Red&quot;, @&quot;Yellow&quot;, @&quot;Orange&quot;,                         @&quot;Green&quot;, @&quot;Blue&quot;, @&quot;Violet&quot;];NSArray *numbers = @[@6,@2,@3,@4,@5];NSArray *cities = [NSArray arrayWithObjects:@&quot;New Delhi&quot;,                    @&quot;London&quot;, @&quot;Brisbane&quot;, @&quot;Adelaide&quot;, nil];//遍历for (NSString *item in colors) &#123;    NSLog(@&quot;%@&quot;, item);&#125;//普通遍历for (int i=0; i&lt;[colors count]; i++) &#123;    NSLog(@&quot;%d: %@&quot;, i, colors[i]);&#125;// 简单排序// 自带的compare:方法，也可以自己写compare:方法[numbers sortedArrayUsingSelector: @selector(compare:)] // 升序 2，3，4，5，6//简单排序，反转使其改为降序[[[numbers sortedArrayUsingSelector: @selector(compare:)] reverseObjectEnumerator] allObjects]//降序 6，5，4，3，2//查找某个元素，结返回布尔值，存在返回 True，不存在返回 False；[colors containsObject:@&quot;Red&quot;]//查找一个元素，若存在返回下标，若不存在返回NSNotFoundNSUInteger index = [colors indexOfObject:@&quot;Red&quot;];//比较两个数组是否相等，每对元素都是同个 isEqual 进行测试的[arr1 isEqualToArray:arr2]//创建一个 NSMutableArrayNSMutableArray * arrM = [NSMutableArray array];//添加一个元素[arrM addObject:@&quot;cwj&quot;];//将一个 NSArray 添加进一个数组中[arrM addObjectsFromArray:@[@&quot;abc&quot;,@&quot;def&quot;]];//插入一个元素到指定下标[arrM insertObject:@&quot;ghi&quot; atIndex:1];\n\nNSString、NSMutableString//初始化一个NSString，stringWithFormat 是个不错的选择NSString *sample = @&quot;iOS Tutorials&quot;;NSString *message = [NSString stringWithFormat:@&quot;That&#x27;s a %@ %@ from %d!&quot;,@&quot;qq&quot;, @&quot;message&quot;, 2021];// isEqualToString 比较两个字符串是否相等, hasPrefix 检查前缀, hasSuffix 检查后缀。NSString *strName = @&quot;Programming Language&quot;;if ([strName isEqualToString:@&quot;Programming Language&quot;]) &#123;    NSLog(@&quot;The name string holds the text Programming Language&quot;);&#125;if ([strName hasPrefix:@&quot;Programming&quot;]) &#123;    NSLog(@&quot;The first name of the word is Programming&quot;);&#125;if ([strName hasSuffix:@&quot;Language&quot;]) &#123;    NSLog(@&quot;The second name of the word is Language&quot;);&#125;//拼接两个或者多个字符串NSLog(@&quot;Combine two strings：%@&quot;, [sample stringByAppendingString:message]);NSLog(@&quot;Combine multiple strings：%@&quot;, [NSString stringWithFormat:@&quot;%@%@%@&quot;,@&quot;String1&quot;,@&quot;String2&quot;,@&quot;String3&quot;]);//字符串查询 查询字符串 text 中是否包含字符串 s；NSString *text = @&quot;this is a string&quot;;NSString *s = @&quot;is&quot;;NSRange searchResult = [text rangeOfString:s];if (searchResult.location == NSNotFound) &#123;    NSLog(@&quot;Search string was not found&quot;);&#125; else &#123;    NSLog(@&quot;location %lu length %lu&quot;,          searchResult.location,\t\t//2\t\t???????????? 为什么是 2 ？？？？          searchResult.length);\t\t\t//2&#125;// 可变 String ???????   使用 setString 对内容进行替换NSMutableString *result = [NSMutableString stringWithString:@&quot;Mutable String Text&quot;];[result setString:@&quot;Modified String&quot;];NSRange range = [result rangeOfString:@&quot; String&quot;];//删除[result deleteCharactersInRange:range]; //Modified//插入[result insertString:@&quot;insert&quot; atIndex:range.location];//替换[result stringByReplacingOccurrencesOfString:@&quot;Modified&quot; withString:@&quot;modified&quot;];  //??????????想实现替换但是这个代码并没有起作用//将 NSMutableString 转换成 NSStringNSString *t = [[result copy] autorelease];\n\nNSNumber// NSNumber 常用的数据类型以及使用方法NSNumber *aBool = @NO;NSNumber *aChar = @&#x27;z&#x27;;NSNumber *anInt = @2147483647;NSNumber *aUInt = @4294967295U;NSNumber *aLong = @9223372036854775807L;NSNumber *aFloat = @26.99F;NSNumber *aDouble = @26.99;NSLog(@&quot;aBool: %@\\n aChar: %@\\n anInt: %@\\n aUInt: %@\\n aLong: %@\\n aFloat: %@ aDouble: %@&quot;,aBool,aChar,anInt,aUInt,aLong,aFloat,aDouble);\n\n\n\n","categories":["技术"],"tags":["Objective-c"]},{"title":"IOS 中页面的跳转","url":"/2021/07/08/2021-7-8-IOS%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B7%B3%E8%BD%AC/","content":"IOS 中页面的跳转下面以OldViewController(oldC)的按钮btn点击后跳转到NewViewController(newC)为例说明:\n\nStoryboard的segues方式\n优点:操作方便,无代码生成,在storyboard中展示逻辑清晰\n缺点:页面较多时不方便查看,团队合作时可维护性差,多人合作时不建议使用这种方式\n\n选项卡UITabBarController控制器\n通过调用UITabBarController的addChildViewController方法添加子控制器\n实例代码:\nUITabBarController *tabbarVC = [[UITabBarControlleralloc] init]; OldViewController *oldC = [[OldViewController] init];oldC.tabBarItem.title = @&quot;控制器1&quot;;oldC.tabBarItem.image = [UIImageimageNamed:@&quot;old.png&quot;];NewViewController *newC = [[NewViewController] init];newC.tabBarItem.title = @&quot;控制器2&quot;;newC.tabBarItem.image = [UIImageimageNamed:@&quot;new.png&quot;];// 添加子控制器（这些子控制器会自动添加到UITabBarController的viewControllers数组中）[tabbarVC addChildViewController:recent];[tabbarVC addChildViewController:friends];\n优点:代码量较少\n\n\n缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar\n\n导航控制器UINavigationController\n在oldC的btn的监听方法中调用:\n[self.navigationController pushViewController:newC animated:YES];　　//跳转到下一页面\n在newC的方法中调用:\n[self.navigationController popViewControllerAnimated:YES];　　//返回上一页面\n当有多次跳转发生并希望返回根控制器时,调用:\n[self.navigationController popToRootViewControllerAnimated:YES];  //返回根控制器,即最开始的页面 \n\n利用Modal形式展示控制器\n在oldC中调用:\n[self presentViewController:newC animated:YES completion:nil];\n在newC中调用:\n[self dismissViewControllerAnimated:YES completion:nil];\n\n直接更改 UIWindow的rootViewController\n\n\n总结:Storyboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用\nUITabBarController因为目前系统的原生样式不太美观,不建议使用\n推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案\n","categories":["技术"],"tags":["IOS"]},{"title":"小站搬家","url":"/2022/02/21/2022-02-21-%E6%90%AC%E5%AE%B6/","content":"\n从 Jekll 迁移到了 hexo，虽然之前的 markdown 迁移过来了，但文件格式还没处理，不少文档显示都存在不少问题，过两天看看整理下。。。(看看得过几天今天是2022-2-21)\n搭建了自己的图床，终于不用忍受免费图床丢我图的苦日子了😄.\n今天又是我开始减肥的第一天。过年和最近没有规律的作息让我胖了不少，大概从90kg胖到了100kg，脸胖了一圈，淦！看看我多久能瘦到80kg，计划奇数天早上运动 40 min。希望能坚持下来✊\n\n\n","tags":["日常"]},{"title":"Flutter BLoC","url":"/2022/03/01/2022-03-01-flutter-bloc/","content":"最近在又又又开始重构我的Flutter项目😇，继上次堆代码把功能实现了然后代码越写越复杂耦合越来越严重💀，于是我决定短痛，推了重写（这次我一定设计（chao）一个好的架构并维护好它💪）。先从业务逻辑和UI组件的结偶下手，决定用这个👉BLoC (Business Logic Components) 模式，BLoC的哲学就是app里的所有东西都应该被认为是事件流：一部分组件订阅事件，另一部分组件则响应事件。BLoC居中管理这些会话。Dart甚至把流（Stream）内置到了语言本身里。这个模式最好的地方就是你不需要引入任何的插件，也不需要学习其他的语法。所有需要的内容Flutter都有提供。\nPS：学起来有点难 😭。　\n\n\n小部件通过Sinks向 BLoC发送事件。\nBLoC 通过流通知小部件。\nBLoC 实现的业务逻辑与他们无关。\n\n这样可以使业务逻辑与 UI 的解耦，这样我么就可以：\n\n我们可以随时更改业务逻辑，对应用程序的影响最小，\n我们可以在不影响业务逻辑的情况下更改 UI，\n现在测试业务逻辑要容易得多。\n\n同时现在也已经有非常受欢迎的Flutter_bloc来支持你实现这个模式：\n\n\n文档在这里\n","categories":["技术"],"tags":["Flutter"]},{"title":"记一次 Mysql 查询条件中字符串尾部空格问题","url":"/2022/03/19/2022-03-19-sql%E7%9A%84%E7%A9%BA%E6%A0%BC%E9%97%AE%E9%A2%98/","content":"记一次 Mysql 查询条件中字符串尾部有空格也能匹配上的问题😇，Bug一个接一个只因为自己太菜。\n表结构\nTABLE fruit\n\n\n\nid\nname\n\n\n\n1\n西瓜\n\n\n2\n西瓜（一个空格）\n\n\n3\n西瓜（二个空格）\n\n\nSQL\nselect * from person where `name` = &quot;西瓜&quot;select * from person where `name` = &quot;西瓜 &quot;\n\n这两条sql都可以把3条数据全部查询出来。\n原因\nMySQL 校对规则属于PADSPACE，会忽略尾部空格，针对的是 varchar char text …… 等文本类的数据类型，此为 SQL 规范。无需要设置也无法改变。\n\n PS: 至于怎么解决我相信你自有妙计\n\n","tags":["MySql"]},{"title":"Hexo 静态博客搭建笔记","url":"/2022/04/01/2022-04-01-deploy-hexo/","content":"Jekyll 被我抛弃的一天,Hexo主题和插件真的是太多了，香\n\n最开始用的是wordpress，后来她也被我抛弃了，不是因为她不够好，而是我们不合适。2333\n\nIntroHexo：快速、简洁且高效的博客框架\n优点\n多语言文档（含中文）\n静态博客，无需服务器\n部署、迁移、备份方便\nGeek\n\n部署跟随文档步骤即可：https://hexo.io/zh-cn/docs/\n推荐主题\nhexo-theme-next：应该是最出名的 Hexo 主题\n\n国内加速我目前使用的是netlify。个人感觉效果不错。\n","categories":["技术"],"tags":["Hexo"]},{"title":"比特币中的密码学原理","url":"/2022/04/14/2022-04-14-%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/","content":"加密货币 ( crypto-currecy )，其中一种加密货币比特币用到了密码学中的两种技术：哈希和签名\n哈希有三个重要的性质，被称为 cryptographic hash function：collision resistance，hiding，puzzle friendly\n\ncollision(这里指哈希碰撞) resistance  :例如x≠y H(x)&#x3D;H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解 ( brute-force )。该性质的作用:对一个 message 求 digest比如message取m m的哈希值是H(m)&#x3D;digest 如果有人想篡改m值而H(m)不变，则无法做到。哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。\nhiding 哈希函数的计算过程是单向的，不可逆的。(从H(x)无法推导出x) hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。该性质的作用:和collision resistance 结合在一起，用来实现 digital commitment(又称为digital equivalent of a sealed envelope)\npuzzle friendly 指哈希值的预算事先是不可预测的。假如哈希值是00…0XX…X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。\n\n签名\n\n比特币中账户管理在第三方中心化系统中，账户开通依赖于第三方。但去中心化的比特币系统中，很明显不能进行“申请账户”。在比特币系统中，申请账户是用户自己来处理的，即自己创建一个公钥-私钥对。（关于公私钥请自行了解非对称加密体系和对称加密体系）公钥和私钥的应用保证了“签名”的应用。当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有私钥，才能将该账户中的比特币转走。【注意：比特币系统中，很难通过生成大量公私钥对来获取他人私钥】\n\n","categories":["技术"],"tags":["区块链"]},{"title":"BTC 共识协议","url":"/2022/04/27/2022-04-27-BTC%20%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/","content":"数字货币中经常出现的问题\n双花攻击数字货币本身为带有签名的数据文件，可以进行复制。即：对用户来说，可以将同一货币花费两次。\n\n\n修改：对货币添加唯一编号（不可篡改），每次支付向货币发行单位查询真伪。该方法每次交易都需要依赖于第三方机构来判断货币真伪且防止双花攻击。是一个典型的第三方中心化方案。现实中，我们通过支付宝、微信、信用卡等各种支付方式交易时，必然会依赖于第三方机构。由于这些第三方机构具有较高的可信度，有政府进行背书，所以可以采用这种方案。但是，很多场景下，并不存在这样一个可信赖的第三方机构。基于这个背景，以去中心化思想为核心的比特币系统便吸引了人们的注意力。\n\n去中心化需要解决的问题\n数字货币的发行由谁执行？如何发行？发行多少？什么时候发行？在传统中心化货币体系中，这些问题我们可以交给第三方机构（如：央行）。当引入去中心化思想后，系统中节点平等，交易不通过第三方，那么货币发行权的分配必然是一个需要解决的问题。\n\n\n在比特币系统中由挖矿来决定货币发行权和发行量。\n\n\n如何验证交易是否有效？如何防止双花攻击？同样，在传统中心化体系中，该问题的解决由第三方机构来完成。而剔除这一机构后，交易双方如何能够验证交易的有效性？如何防止系统中恶意用户作恶获取收益？这也是去中心化交易系统需要解决的问题。\n\n\n该问题的解决，依赖于系统中维护的一个数据结构，记录货币的使用情况（是否被花过？被谁花过？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。\n\n案例说明如下，假定A获得铸币权，新新发布了10个比特币（该交易称为铸币交易）。A将10个比特币转给了B(5个)和C(5个)，A对该交易进行签名，同时该交易需要说明所花掉10个比特币来源（来自铸币交易）。之后，B将自己的5个比特币转给C(2个)和D(3个)，该交易需要B的签名，该交易需要说明所花掉的5个比特币来自于第二个交易中。然后，C将自己所拥有的全部7个比特币都转给E，并对该交易签名，可以发现该交易中C的比特币来源于两个交易中。这样，就构成了一个简单的区块链。【红色部分为比特币来源】\n\n需要注意的是，这里面有两种哈希指针。第一种为指向前面的区块（白色），使得各个区块形成链，第二种则是为了说明比特币的来源（红色）。说明比特币的来源并非凭空捏造，可以防止双花攻击。在进行交易时，需要付款人的签名和收款人的地址，在比特币系统中，该地址即为收款人的公钥的哈希。可以将其视为银行账户，根据此进行转账交易。（虽然公钥可以公开，但实际中更多公开的是公钥的哈希）在交易中，收款方需要知道付款方的公钥，从而验证A签名是否有效。即A需要提供自己的公钥，如果所提供公钥与铸币交易中。（实际上其他节点都需要知道付款方公钥，验证交易合法性）实际中A转账时候提供的公钥需要和铸币交易中公钥对的上，这样就防止了恶意节点伪造A的公钥来“偷”走A的比特币。在比特币系统中，通过执行脚本实现上述验证过程。将当前交易输入脚本与前一个交易输出脚本（说明币的来源的交易）拼接执行，如果可以正确执行，说明交易合法。在该图中，一个区块仅含有一个交易，实际中一个区块中包含多个交易，交易通过Markle Tree（详见比特币数据结构篇中）组织起来，在区块中存储。\n\n比特币区块信息\n\n\nblock Header（区块宏观信息）\nblock body(略)\n\n\n\nVersion(版本协议)\n…\n\n\nHash of previous block header（指向前一个区块指针）\n…\n\n\nMerkle root hash（默克尔树根哈希值）\n…\n\n\ntarget（挖矿难度目标阈值）\n…\n\n\nnonce（随机数）\n…\n\n\n\n\n挖矿求解问题：Hash（block header）&lt;&#x3D;target\nHash of previous block header只计算区块块头部分的哈希（ Merkle root hash保证了block body内容不被篡改，所以只需要计算block header即可保证整个区块内容不会被篡改）\n区块链系统中，轻节点（只存储区块block header信息）只利用区块链，但并不参与区块链系统维护和构造。\n\n\n分布式共识\n可否各个节点独立完成区块链构建？很明显不行，各个节点独立打包交易，形成区块链，必然无法避免区块链内容不一致。从分布式系统角度来说，账本内容需要取得分布式共识，从而保证区块链内容在不同节点上的一致性。\n\n根据FLP不可能结论，在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。根据CAP Theorem（Consistency一致性、Availability可靠性、Partition tolerance容错性），任何一个分布式系统中，最多只能满足其中两个性质。分布式共识中协议Paxos 可以保证Consistency（若达成共识必然一致），但在某些情况下，可能会一直无法达成共识。\n比特币共识协议\n背景：假设系统中存在部分节点有恶意，但存在比例较小。大多数节点为“好”的节点，在这种情况下进行共识协议设置。想法1：直接投票某个节点打包交易到区块，将其发给其他节点，其他节点检查该候选区块，检查若正确投赞成票，若票数过半数，加入区块链。存在的问题1——恶意节点不断打包不合法区块，导致一直无法达成共识，时间全花费在投票上。存在的问题2——无强迫投票手段，某些节点不投票（行政不作为）。存在的问题3——网络延迟事先未知，投票需要等多久？效率上会产生问题。更大的一个问题——membership。如果是联uoyi s盟链，对加入成员有要求，可以基于投票。但比特币系统，任何人都可以加入，且创建账户及其简单，只需要本地产生公私钥对即可。只有转账（交易）时候,比特币系统才能知道该账户的存在。这样，黑客可以使用计算机专门生成大量公私钥对，当其产生大量公私钥对超过系统中一半数目，就可以获得支配地位（女巫攻击）。所以，这种简单的投票方案也是不可行的。\n\n比特币系统中采用了很巧妙的方案解决这个问题。虽然仍然是投票，但并非简单的根据账户数目，而是依据计算力进行投票。在比特币系统中，每个节点都可以自行组装一个候选区块，而后，尝试各种nonce值，这就是挖矿。[H(block header)&lt;&#x3D;target]当某个节点找到符合要求的nonce，便获得了记账权，从而可以将区块发布到系统中。其他节点受到区块后，验证区块合法性，如果系统中绝大多数节点验证通过，则接收该区块为最新的区块并加入到区块链中。\n\n\n会不会合法区块被拒绝？如图所示。发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。这样，也就会导致合法区块被拒绝\n分叉攻击如图所示，A用户对上面的A转账给B的记录回滚，从而非法获取利益。在两条链上，发现交易都合法。这是一个典型的双花攻击。A给B转账后，用分叉攻击将钱又转回来，覆盖掉原来的记录。在比特币系统中，这种情况实际上很难发生。因为大多数矿工认可的是最长的合法链，会沿着上面的链继续挖下去。而A这个攻击者要想回退记录，就必须使得下面的链变得比上面的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力，才能使得这种攻击成功。此外，区块链正常运行场景下，也可能会发生分叉。当两个节点同时获得记账权时，会有两个等长的合法链。在缺省情况下，节点接收最先听到的区块，该节点会沿着该区块继续延续。但随着时间延续，必然有一个链胜出，由此保证了区块链的一致性。（被扔掉的区块称为“孤儿区块”)\n\n\n可见，依赖于算力竞争，有效的防止了“女巫攻击”。\n比特币激励机制\n为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？\n\n比特币系统设计之初便考虑到了这个问题，那就是引入激励机制。比特币通过设置出块奖励来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。事实上，这种方式也是唯一一个产生新比特币的途径。\n\n比特币系统设计规定，起初每个区块可以获得50个比特币，但之后每隔21万个区块，奖励减半。\n\n但是这样就可以了吗？？？区块中保存交易记录，那么，会不会存在节点只想发布区块而不想打包交易？中本聪在设计该系统时，引入了交易费。在一个区块中，其输入&gt;&#x3D;输出，差值便是给区块所属节点的手续费。\n","categories":["技术"],"tags":["区块链"]},{"title":"如何实现区块链系统","url":"/2022/04/28/2022-04-28-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F/","content":"区块链是一个去中心化的账本，比特币采用了  基于交易的账本模式  。然而，系统中并无显示记录账户包含比特币数，实际上其需要通过交易记录进行推算。在比特币系统中，全节点需要维护一个名为  UTXO(Unspent Transaction Output尚未被花掉的交易输出)  的数据结构。\n\n如图，A转给B五个BTC，转给C3个BTC，B将5个BTC花掉，则该交易记录不保存在UTXO中，C没有花掉，则该交易记录保存在UTXO中\n\nUTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出。\n\n为什么要维护这样一个数据结构？？？为了防范“双花攻击”，判断一个交易是否合法，要查一下想要花掉的BTC是否在该集合中，只有在集合中才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么根本不存在，要么已经被花过。所以，全节点需要在内存中维护一个UTXO，从而便于快速检测double spending（双花攻击）。\n\n每个交易会消耗输出，但也会产生新的输出。\n\n如图，A转给B5个BTC，之后B将其转给D，则UTXO中会删掉A-&gt;B这一交易记录，同时会添加B-&gt;D这一交易记录。假如有人收到BTC转账，但一直不花，那么这个信息会一直保存在UTXO中。这种情况可能是该用户不想花这些BTC(如：中本聪) ，也有可能是忘记了私钥导致无法花掉。所以，UTXO是逐渐增大的，但该数据目前来说，一个普通的服务器硬盘中是可以完全保存这些数据的。\n\n每个交易可以有多个输入，也可以有多个输出，但输入之和要等于输出之和（total inputs &#x3D; total outputs）。存在一些交易的total inputs 略大于 total outputs，这部分差额便作为交易费，给了获得记账权的节点。在公开课笔记4中最后提及到“区块中保存交易记录，如果仅仅设置出块奖励，那么，会不会存在节点只想发布区块获得出块奖励而不想打包交易？”因此，BTC系统设计了Tranction fee（交易费），对于获得记账权节点来说，除了出块奖励之外，还可以得到打包交易的交易费。但目前来说，交易费远远小于出块奖励。等到未来出块奖励变少，可能区块链的维护便主要依赖于交易费了。\n\nBTC系统中每21万个区块，BTC出块奖励减半。根据下图计算，基本上出块奖励每4年减半。\n\n\n比特币是基于交易的模式，与之对应，还有一种基于账户的模式（如：以太坊）。基于账户的模式要求，系统中显示记录账户余额。也就是说，可以直接查询当前账户余额是多少货币。可以看到，比特币这种模式，隐私性较好，但其也付出一定代价。在进行交易时，因为没有账户这一概念，无法知道账户剩余多少BTC,所以必须说明币的来源（防止双花攻击）。而基于账户的模式，则天然地避免了这种缺陷，转账交易就是对一个（多个）账户余额的数字减和另一个（多个）账户余额的数字加\n\nBTC系统中具体的区块信息如下图所示，为一个区块的信息（取自视频中截图，源自blockchain.info）\n\n什么是挖矿？可以看到，区块哈希与前一区块哈希都是以一长串0开头的，挖矿本身就是尝试各种nonce，使得产生的区块哈希值小于等于目标阈值。该目标阈值，表示成16进制，就是前面含有一长串的0\n\n\n下为block header的代码中实现的数据结构。里面的几个域在公开课笔记4中(比特币区块信息)已经解释过了，这里不再赘述。可以看到，nonce是一个32位的无符号整型数据，在挖矿时候是通过不断调整nonce进行的，但可以看到，nonce的取值最多为2^32 (2的32次方)种。但并非将这些nonce全部遍历一遍，就一定能找到符合要求的nonce。由于近年来，挖矿人员越来越多，挖矿难度已经调整的比较大了（关于难度调整请关注后续博文，会有专门一篇介绍难度调整)，而2^32这一搜索空间太小，所以仅调整nonce很大可能找不到正确的结果。\n\n还有哪些域可以调整呢？\n\n下图为block header中对各个域的描述。而仅仅调整nonce是不够的，所以这里可以通过修改Merkle Tree的根哈希值来进行调整。\n\n思考：打包的交易和顺序确定了，根哈希值不就确定了吗？这个怎么能修改呢？\n\n铸币交易（coinbase交易）在公开课笔记4中提及，每个发布区块者可以得到出快奖励，也就是可以在区块中发布一个  铸币交易(coinbase交易)  ,这也是BTC系统中产生新比特币的唯一方式。下为一个铸币交易的内容：可以看到，有一个CoinBase域，其中可以写入任何内容，在这里写什么都没有影响。所以可以在这里添加一些任意信息，便可以实现无法篡改（也无法删除）。（例如：提前写入股票预测结果的哈希值、写入人生感想，写入爱情誓言（无法删除，想想删不掉十年前发表的QQ空间非主流说说是多么痛苦吧，嘿嘿嘿）)所以，只要我们改变了写入内容，便可以改变Merkle Tree 的根哈希值。  \n下图为一个小型的区块链，假定左下角交易为coinbase交易，可以看到，该交易发生改变会逐级向上传递，最终导致Merkle Tree根哈希值发生改变。所以，在实际的挖矿中，包含两层循环。外层循环调整coinbase域（可以规定只将其中前x个字节作为另一个nonce)，算出block header中根哈希值后，内层循环再调整nonce。\n普通转账交易如果将输入脚本和输出脚本拼接起来可以顺利执行不出现错误，则说明交易合法。\n挖矿过程的概率分析挖矿本质上是不断尝试各种nonce，来求解这样一个puzzle。每次尝试nonce，可以视为一次伯努利试验。最典型的伯努利试验就是投掷硬币，正面和反面朝上概率为p和1-p。在挖矿过程中，一次伯努利试验，成功的概率极小，失败的概率极大。挖矿便是多次进行伯努利试验，且每次随机。这些伯努利试验便构成了a sequence of independent Bernoulli trials(一系列独立的伯努利试验)。根据概率论相关知识知道，伯努利试验本身具有无记忆性。也就是说，无论之前做多少大量试验，对后续继续试验没有任何影响（车牌摇号也是如此，，心痛…）。对于挖矿来说，便是多次伯努利试验尝试nonce，最终找到一个符合要求的nonce。在这种情况下，可以采用泊松分布进行近似，由此通过概率论可以推断出，系统出块时间服从指数分布。(需要注意的是，出块时间指的是整个系统出块时间，并非挖矿的个人)系统平均出块时间为10min，该时间为系统本身设计，通过难度调整维护其平均出块时间。指数分布本身也具有无记忆性。也就是说，对整个系统而言，已经过去10min，仍然没有人挖到区块，那么平均仍然还需要等10min（很不符合人的直觉)。也就是说，将来要挖多久和已经挖多久无关。\n\n虽然这样看起来是一个冷酷的事情，过去的工作可能都会白做。但实际上这才是挖矿公平性的保障。对算力有优势的矿工来说，其之前所做大量工作仍有可能会白费。\n\n比特币总量计算也就是说，比特币系统中已经挖出和未挖出的比特币总数便是2100万个。实际上，挖矿这一操作并非在解决数学难题，而是单纯的算力比拼。也就是说，挖矿这一过程并没有实际意义，但挖矿这一过程，却是对比特币系统的稳定起到重要维护作用。所以，只要大多数算力掌握在好的节点手中，便能够保障比特币系统的稳定。\n\n比特币越来越难被挖到，且出块奖励越来越少，是否说明其未来挖矿的动力将越来越低呢？实际上，恰恰相反。在早期比特币很容易挖到的时候，比特币并不被人们所看好，而后，比特币估值上涨，吸引其他人参与挖矿，又进一步促进了比特币价值上涨，进而又吸引更多人参与进来。当出块奖励趋于0时，则整个系统将依赖于交易费运行，届时交易费将成为维护比特币系统运行的重要保障。\n\n比特币系统安全性分析\n大多数算力掌握在好的用户手中，能否保障不良交易记录不会被写入区块链？需要注意的是，算力低的用户并非完全不能获得记账权，仅仅是概率上较低的问题。但实际上，即使拥有少量算力的恶意节点，也有一定概率获得某个区块的记账权。\n\n\n\n可否”偷币”？（恶意节点能不能将其他账户上比特币转给自己？）答案：不能。因为转账交易需要签名，恶意节点无法伪造他人签名。加入其获得记账权并硬往区块中写入该交易，大多数用户会认为其是一个非法区块，大多数算力将不认可该区块，从而沿着其他路径挖矿，随着时间推移，拥有大多数算力的诚实的节点将会仍然沿着原来区块挖矿，从而形成一条“最长合法链”，该区块变成孤儿区块。对于攻击者来说，不仅不能偷到其他人的比特币，而且得不到出块奖励，还浪费了挖矿花费的电费等成本。\n\n\n\n可否将已经话过的币再花一遍？如下图1，若M已经将钱转给B，现在想再转给自己，假设其获得记账权，若按照图1方式，很明显为一个非法区块，不会被其他节点承认。所以，M只能选择图2方式，将M转账给B的记录回滚掉。这样就有了两条等长合法链，取决于哪一个会胜出。（如果上面交易产生不可逆的外部效果，下面交易回滚便又拿回钱，从而不当获益）\n\n\n\n\n需要注意的是，再挖矿之初便要选择上一个区块是谁。也就是说，并不是获得记账权之后才选择插入到哪一个区块之后。\n\n如何防范这种攻击？？？如果再M-&gt;B这个交易之后还延续有几个区块，如下图所示，则大多数诚实节点不会承认下面的链。所以，便变成了恶意节点挖下面的链，其他节点挖上面的链的算力比拼。由于区块链中大多数节点为善意节点，则最终上面链会胜出，而恶意节点的链会不被认可，从而导致投入成本白费。所以，一种简单防范防范便是多等几个确认区块。比特币协议中，缺省需要等6个确认区块，此时才认为该记录是不可篡改的。平均出块时间10min，六个确认区块便需要1小时，可见等待时间还是相对较长的。\n\n\n可否故意不包含合法交易？可以，但是可以等待后续区块包含，所以问题不大。实际运行中，可能由于某段时间实际交易数太多，而一个区块包含交易数存在最大值，导致某些合法交易并未被写入区块链（等待后续区块写入）。\n\n\n\nselfish mining提前挖到但不发布，继续挖下去，等到想要攻击的交易等了6次确认认为安全之后将整条链发布出去，试图回滚原来记录。这种情况，需要恶意节点掌握系统中半数以上算力才行，否则无法成为最长合法链。\n\n\n\n\nselfish mining有好处吗？如图所示，假使挖到2号时候先不发布，则其他人仍然需要挖1号区块，若其算力足够强，能保证别人挖出1之后可以挖出3.可以此时将2和3一起发布，从而将1区块所在链最长合法链挤掉（减少了别人和自己竞争挖3号区块）。但这样存在风险，如果别人已经挖出1，自己还没挖出3，则需要尽快发布2和别人竞争最长合法链地位。\n\n需要注意的是，比特币系统中，假如发生以下情况，各个节点以自己先收到的区块所在链为主链，对后收到的合法区块会不予认可（但会先保存起来）。此时便变成了两批算力分布挖1和2，具体哪一个成为主链，取决于哪一条链先挖到下一个区块，使得两个等长合法链出现长短不一致，最终胜者成为最长合法链。\n","categories":["技术"],"tags":["区块链"]},{"title":"Hexo使用Github Action自动部署","url":"/2022/04/29/2022-04-29-Hexo%E4%BD%BF%E7%94%A8Github-Action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","content":"使用Hexo搭建博客后，用 Github Action 自动部署。\n\n再见👋 NodeJS，**** u。\n\n在你的 Github 仓库中点击 Action 按钮，如果你从来都没有创建过Action，那么再点击I understand my workflows, go ahead and enable them按钮，然后复制下面的配置。去看Github的最近你添加Action的那次提交是否正常执行，相信你一定幸运的得到了自己想要的结果。如果你不够幸运，那就点❌看看报错信息，相信最终你会成功。\n\nhttps://github.com/features/actions 它可能会有帮助\n\nname: Pageson:  push:    branches:      - master  # 要编译的分支jobs:  pages:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2        with:          submodules: recursive      - name: Use Node.js 17.x        uses: actions/setup-node@v2        with:          node-version: &#x27;17&#x27;   # NodeJs的版本根据你本地的版本写      - name: Cache NPM dependencies        uses: actions/cache@v2        with:          path: node_modules          key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache          restore-keys: |            $&#123;&#123; runner.OS &#125;&#125;-npm-cache      - name: Install Dependencies        run: npm install      - name: Build        run: npm run build      - name: Deploy        uses: peaceiris/actions-gh-pages@v3        with:          github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          publish_dir: ./pub # 要发布的目录，也可能叫 publish，\n\n","categories":["技术"],"tags":["Github"]},{"title":"栈(Stack)与堆(Heap)简单了解","url":"/2022/04/29/2022-04-29-%E6%A0%88(Stack)%E4%B8%8E%E5%A0%86(Heap)%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/","content":"栈和堆是编程语言最核心的数据结构，但是在很多语言中帮助你做了大量工作，一般来讲你或许并不需要深入了解栈与堆。但知道这些或许会让你更加了解你的程序是如何运行的。\n栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。\n栈栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！\n增加数据叫做进栈，移出数据则叫做出栈。\n因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。\n\n栈是向低地址扩展的数据结构，是一块连续的内存的区域。在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\n\n堆与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。\n当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。\n接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。\n由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。\n性能区别写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。\n读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。\n因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。\n","categories":["技术"],"tags":["基础知识"]},{"title":"Dart异步Stream和Future","url":"/2022/05/11/2022-05-11-Dart%E5%BC%82%E6%AD%A5Stream%E5%92%8CFuture/","content":"前言：初学Flutter时，是因为被她的全平台和性能所吸引，没什么耐心的我粗略的看了dart的新手guide简单的看了Flutter的例子之后，感觉Dart语法和Java或者说Javascript差别不是很大，当时的我觉得并没有什么难度，异步编程也一知半解，看了Future之后就没继续看下去了。结果给自己埋了一个大坑（。\n这里我简单介绍一下我对Future和Stream是Dart语言处理非同步事件的二大核心类别，你是否觉得二者很容易搞混，或是对它俩一知半解呢？其实只要一个简单的观念你马上就会觉得「喔~~原来是这样！」，并且永远不会再搞错了！\n\n有了这两种异步之后，就可以解决Flutter中生命周期中一些页面数据更新的问题了!\n\n其实官方对他们的定义就非常准确了\nFuture\n\nA Future represents a computation that doesn’t complete immediately. Where a normal function returns the result, an asynchronous function returns a Future, which will eventually contain the result. The future will tell you when the result is ready.\n\nFuture代表一个不会立即完成的计算过程，不同于一般函式回传一个结果，一个非同步函式是回传一个Future，你会一直等待到Future执行完成后才会取得最后结果。\nStream\n\nA stream is a sequence of asynchronous events. It is like an asynchronous Iterable — where, instead of getting the next event when you ask for it, the stream tells you that there is an event when it is ready.\n\nStream是一个非同步的事件序列，它就如同一个非同步的循环，你可能无法在向Stream取得事件的当下取得资料，只要你尚未停止「取得事件」的状态，你将会在最新事件准备好时通知你。\n如果你还是不明白，我给你打个比方：\n现在有一家餐厅，他会制作出食物（数据），Future获得到食物就类似于你订外卖（或者到店取餐），就是等到食物做好之后，他会一次性给你。而Stream则是你到店里吃，服务员可以做完一道菜之后给你上一道菜，这是一个持续性的过程。\n","categories":["技术"],"tags":["Dart"]},{"title":"比特币挖矿的故事","url":"/2022/05/12/2022-05-12-%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E7%9A%84%E6%95%85%E4%BA%8B/","content":"在比特币网络中，大多数节点都是轻节点。如果只是想进行转账操作，不需要挖矿，就无需运行一个全节点。在挖矿过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，在本地重新组装一个指向最后这个新合法区块的候选区块，重新开始挖矿。\n\n这样是不是有些可惜？之前花费好多资源，全部白挖了。实际上并不可惜。之前文章中提及，挖矿本身具有无记忆性，前面无论挖多久，对后续继续挖矿没有影响。\n比特币系统如何安全性？一是密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账户上BTC转走。（前提：系统中大多数算力掌握在好人手中）二是共识机制：保证了恶意交易不被系统承认。\n\n\n\n\n全节点\n轻节点\n\n\n\n一直在线\n不是一直在线\n\n\n在本地硬盘上维护完整区块链信息\n不保存整个区块链，只需要保存每隔区块块头\n\n\n在内存中维护UTXO集合，以便于快速检验交易合法性\n不保存全部交易，只保存和自己有关的交易\n\n\n监听比特币网络中交易内容，验证每个交易合法性\n无法验证大多数交易合法性，只能检验和自己相关的交易合法性\n\n\n决定哪些交易会打包到区块中\n无法检测网上发布的区块正确性\n\n\n监听其他矿工挖出的区块，验证其合法性\n可以验证挖矿难度\n\n\n挖矿： 1. 决定沿着哪条链挖下去。 2. 当出现等长分叉，选择哪一个分叉\n只能检测哪个是最长链，不知道哪个是最长合法链\n\n\n挖矿设备演化目前，挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。普通CPU -&gt; GPU -&gt;ASIC芯片（挖矿专用矿机）\n\n实际上，挖矿本身就是计算，对于普通计算机来说，挖矿过程中大多数内存、硬盘、CPU中大多数部件（用到指令较少）等都是闲置的，如果用普通计算机专门用于挖矿是根本不划算的。随着挖矿难度提高，用通用计算机挖矿很快变得无利可图。所以，挖矿设备转入第二代——GPU(主要用于大规模并行计算，如：深度学习)。但是，用GPU挖矿，仍然有一定浪费(GPU为通用并行计算设计，挖矿仍然有很多部件闲置。例如：浮点数运算部件，挖矿过程只使用整数操作，该部分部件根本不会用到)。\n\nGPU价格上涨，仅仅是深度学习火热导致的吗？实际上，很多GPU被用于了挖矿。\n\n当然，目前GPU挖矿也已经不划算了（目前一些新开发货币仍然用GPU挖矿）。所以，开始进入第三代设备：ASIC芯片（专门为挖矿设计的芯片），这种芯片专门为挖矿设计，只能用于特定币种的挖矿。但ASIC芯片设计、流片流程很长，假如BTC价格剧烈变化，前期投入很可能会血本无归。所以，ASIC芯片需要提前预订。假如BTC系统中，算力突然很猛烈增加，一般是一个大的厂商生产出新的ASIC矿机。\n\nASIC芯片只能用于挖矿，一旦其过时，便完全作废。\n思考：ASIC芯片的出现是好事吗？很明显，ASIC芯片并不是普通人可以参与的，一定程度上提升了挖矿的门槛，违背了比特币系统去中心化的初衷。理想状态下，所有人用CPU挖矿，这样只要有一台家用计算机便可以参与挖矿。当然，后续有一些货币便考虑到了这个问题，设计了抗ASIC芯片化的解决方案，后续介绍以太坊时会对这种方案进行介绍。但反过来想，如果大家都用ASIC矿机挖矿，如果有人想要颠覆BTC系统，必然会导致BTC价格跳水，从而导致其所购买ASIC矿机作废，投入成本血本无归。所以，很多人反倒认为ASIC芯片出现，一定程度上并不是坏事。\n大型矿池出现\n挖矿另一个趋势便是大型矿池的出现。对于单个矿工来说，即使使用了ASIC矿机，其算力在整个系统中仍然只占据很少一部分，即使从平均收益看有利可图，但收入很不稳定。此外，单个矿工除挖矿还要承担全节点其他责任，造成了算力的消耗。\n\n因此，为了解决这些问题，便引入了矿池的概念。矿池的架构如下图，通常是一个全节点驱动多台矿机。矿工只需要不停计算哈希值，而全节点其他职责由矿主来承担。ASIC芯片只能计算哈希值，不能实现全节点其他功能。此外，矿池出现解决了单个矿工收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。\n\n所以，必须涉及如何分配的问题。如果分配不公平，挖矿的动力就会减少。\n\n矿池一般具有两种组织形式。1.类似大型数据中心（同一机构），集中成千上万矿机进行哈希计算。2.分布式。矿工与矿主不认识(不同机构)，矿工与矿主联系，自愿加入其矿池，矿主分配任务，矿工进行计算，获得收益后整个矿池中所有矿工进行利益分配。\n矿池利益分配方法假使第二种情况，矿工来源于五湖四海（非同一机构），收益应该如何分配？\n\n思路一：平均分配，所有人平分出块奖励。这一点有些类似我国某段历史时期，大家一起”吃大锅饭”，会导致某些矿工懈怠，不干活（挖矿要费电，需要成本）。所以，这里也需要进行按劳分配，需要一个工作量证明的方案。如何证明每个矿工所作的工作量呢？\n思路二：降低挖矿难度（可行方案）。假设原本挖矿难度要求，计算所得126位的哈希值前70位都必须为0，现在降低要求，只需要前60位为0，这样挖矿会更容易挖到。当然，这个哈希是不会被区块链所承认的，我们将其称为一个share，或almost valid share。矿工每挖到一个share，将其提交给矿主，矿主对其进行记录，作为矿工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的share数量进行分配。因为每个矿工尝试的nonce越多，挖到矿的可能性越大，所能得到的share也会越多，所以这种方案作为工作量证明方案是可行的。\n\n\n思考一：有没有可能，某个矿工平时正常提交share，但真正挖到区块后不提交给矿主而是自己偷偷发布出去，从而避免他人分走挖矿所得到的出块奖励？事实上，这种情况是不可能的。因为每个矿工挖矿任务是矿主分配的。矿主组装区块，交给矿工计算，而区块中铸币交易的收款人地址是矿主，如果矿工修改该地址，计算的nonce值也会作废。思考二：如果矿工自己刚开始就自己偷偷组装一个区块，自己挖矿，这样就类似于其脱离了该矿池。因为其自己所组织的区块不会被矿主所认可，其提交的share也不会被认可，也就得不到分配的收益。思考三：有没有可能矿工捣乱？平时提交share，等挖到后扔掉区块，不提交？这种可能是有的，如果矿工本身仅仅想捣乱，是可以这么做的。但扔掉区块后，对其本身来说，也没有相应的奖励获得，看似是损人不利己的情况。但是，矿池之间存在竞争关系。有可能为了打击竞争对手，会派出矿机加入竞争对手矿池挖矿，从而起到搞破坏的作用。即只参与其他矿工挖矿分红，自己挖到的区块却丢掉不给他人分。\n\n关于矿池的一些统计数据\n图1：矿池在各个国家分布比例图（2018年）\n\n可见，中国所占矿池比例远远超过其他国家。\n\n图2：2014年图单个矿池算力分布比例图\n\n这个时间，存在一个矿池(GHash.IO)算力比例占据全部算力一半以上，当时引起了恐慌(一个矿池就可以发动51攻击)。之后，该矿池主动降低了矿池算力（化整为零，实际上仍然存在发动51攻击能力），避免动摇人们对比特币信心。\n\n图3：2018年图单个矿池算力分布比例图\n\n表面看上去是安全的，但实际实上某个机构如果有超过50%算力，其必然不会将其放入一个矿池中。而是将其分散隐藏，真正需要发动攻击时候再集中起来发动51攻击（注意：矿工转换矿池是很容易的）。\n\n由这些数据可以得知，矿池本身对BTC系统带来了较大威胁。某个恶意用户如果想发动攻击，以前需要自己达到51%算力，现在自己只需要作为矿主，只需要很少一部分算力就可以了。只要能够吸引到足够多的不明真相的矿工，便可以用较低成本实现51攻击。当然，矿主经验管理矿池，也需要收取一定比例(出块奖励、交易费)作为管理费用。如果恶意者想要攻击系统，会将管理费降低甚至赔本吸引足够多矿工加入。这便使得发动51%攻击变得容易了起来。\n\n51%算力矿池可以发动哪些攻击\n分叉攻击对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。\n\n\n矿工只能计算哈希值，并不知道区块包含哪些交易，区块链状况是什么。所以，这些“群众”是无知的，容易被利用（《乌合之众》当中提出的观点，大多数人真的就能掌握真理吗？）。此外，51%攻击只是一个概率问题，并非达到51%算力就能发动攻击，不能达到就无法发动攻击。此外，矿池本身算力也是在不断变化的。\n\n\n封锁交易（Boycott）假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。\n\n\n像不像即当裁判又当运动员？”堂下何人状告本官“？\n\n\n盗币（将他人账户BTC转走）这个是不可能的，因为其并没有他人账户私钥。如果依仗算力强，强行将没有签名的转账发布到区块链，正常节点不会认为其合法，这样，即使这条链再长，其他人也不会认为其是最长合法链。\n\n矿池出现的优劣优点：解决了矿工收入不稳定的问题，减轻了矿工的负担。缺点：威胁到了区块链系统的安全，使得51%攻击变得容易起来。\n","categories":["技术"],"tags":["区块链"]},{"title":"深拷贝和浅拷贝","url":"/2022/05/24/2022-05-24-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":"大多数对象的设计目标是提供由一个整体块制成的相似性，尽管大多数对象并非如此。由于对象由几个不同的部分组成，因此复制变得非常重要。有几种策略可以解决这个问题。\n考虑一个对象 A，它包含字段 xi（更具体地说，考虑 A 是否是一个字符串，而 xi  是它的字符数组）。制作 A 的副本有不同的策略，称为浅拷贝和深拷贝。许多语言允许通过一种或两种策略进行通用复制，定义一个复制操作或单独的浅复制和深复制操作。请注意，更浅的方法是使用对现有对象 A 的引用，在这种情况下没有新对象，只有新引用。\n浅拷贝复制对象的一种方法是浅拷贝。在这种情况下，将创建一个新对象 B ，并将 A 的字段值复制到 B。这也称为*逐字段复制(field-by-field)*， 字段对字段副本(field-for-field copy)，或字段复制(field copy)。如果字段值是对对象的引用（例如，内存地址），则它复制该引用，因此引用与 A 相同的对象，如果字段值是原始类型，则复制原始类型的值。在没有原始类型的语言中（一切都是对象），副本 B 的所有字段都是对与原始 A 的字段相同的对象的引用。因此，引用的对象是共享的，因此如果修改了这些对象之一（来自 A或 B)，更改在另一个中可见。浅拷贝很简单而且通常很便宜，因为它们通常可以通过简单地精确复制位来实现。\n深拷贝另一种方法是深拷贝，这意味着字段被取消引用：不是对正在复制的对象的引用，而是为任何被引用的对象创建新的副本对象，并将对这些对象的引用放在 B 中。结果与浅拷贝给出的结果不同因为副本 B 引用的对象与 A 引用的对象不同，并且是独立的。由于需要创建额外的对象，深拷贝更昂贵，并且由于引用可能形成复杂的图，因此可能更加复杂。\n深拷贝是复制过程递归发生的过程。这意味着首先构造一个新的集合对象，然后递归地用在原始集合中找到的子对象的副本填充它。在深拷贝的情况下，对象的副本被复制到其他对象中。这意味着对对象副本所做的任何更改都不会反映在原始对象中。在 python 中，这是使用“deep copy()”函数实现的。\n在 Java 中Java 中的对象总是通过引用间接访问。对象永远不会隐式创建，而是始终由引用变量传递或分配。（Java 中的方法总是按值传递，但是，传递的是引用变量的值。）Java 虚拟机管理垃圾收集，以便在对象不再可访问后对其进行清理。在 Java 中没有自动复制任何给定对象的方法。\n复制通常由类的clone() 方法执行。该方法通常依次调用其父类的 clone() 方法来获取副本，然后执行任何自定义复制过程。最终到达Object（最上面的类）的 clone() 方法，该方法创建一个与对象相同的类的新实例，并将所有字段复制到新实例（“浅拷贝”）。如果使用此方法，则该类必须实现Cloneable标记接口，否则将抛出CloneNotSupportedException。在从父类获得副本后，类自己的 clone() 方法可以提供自定义克隆功能，如深度复制（即复制对象引用的某些结构）或为新实例提供新的唯一 ID。\nclone() 的返回类型是Object，但是由于 Java 对协变返回类型的支持，克隆方法的实现者可以编写被克隆对象的类型。使用 clone() 的一个优点是，由于它是一个可覆盖的方法，我们可以在任何对象上调用 clone()，它将使用其类的 clone() 方法，而调用代码不需要知道该类是什么（复制构造函数需要）。\n一个缺点是通常无法访问抽象类型上的 clone() 方法。Java 中的大多数接口和抽象类都没有指定公共 clone() 方法。因此，通常使用 clone() 方法的唯一方法是对象的类是已知的，这与使用可能的最通用类型的抽象原则背道而驰。例如，如果在 Java 中有一个 List 引用，则不能对该引用调用 clone()，因为 List 没有指定公共 clone() 方法。ArrayList 和 LinkedList 等 List 的实现通常都有 clone() 方法，但是携带对象的类类型不方便且抽象不好。\n在 Java 中复制对象的另一种方法是通过接口将它们序列化。Serializable这通常用于持久性和有线协议的目的，但它确实创建了对象的副本，并且与克隆不同，一个优雅地处理对象循环图的深层副本很容易获得，而程序员只需最少的努力。\n这两种方法都有一个明显的问题：构造函数不能用于通过克隆或序列化复制的对象。这可能会导致数据初始化不正确的错误，阻止使用final成员字段，并使维护变得困难。一些实用程序试图通过对深度复制对象使用反射来克服这些问题，例如深度克隆库。[\n","categories":["技术"],"tags":["编程"]},{"title":"zerotier局域网游戏无法搜到游戏房间","url":"/2022/05/29/2022-05-29-zerotier-one/","content":"这个解决方案也适用于那些使用虚拟 LAN 的人，你和你的朋友可以相互 ping 通。我只是在描述我和一个朋友在此修复工作的确切情况&#x2F;环境。\n我们被困在朋友1可以 ping 朋友2，朋友2 ping 到朋友1，但在局域网游戏中搜索时无法找到对方。\n做了一些谷歌搜索，发现可能的罪魁祸首是 BL3 在扫描 LAN 游戏时没有查看正确的适配器。例如，它查看的是普通的 Internet 适配器，而不是虚拟网络适配器。\n解决此问题的方法是将虚拟网络适配器设置为更高优先级的选择。\n这是通过进入您的网络适配器并进行以下修改来完成的。\n（查找如何自己访问您的网络适配器） \n在您的 MAIN&#x2F;NORMAL Internet 适配器上，转到属性 -&gt; Internet 协议版本 4 属性 -&gt; 高级。\n关闭自动设置，然后手动将其设置为高于数字 1 的任何值（在我的情况下，我将其设置为 100，我的朋友也是如此）确定更改。\n对你的虚拟网络适配器（在我的例子中，ZeroTier One [nodeid]）做同样的事情，除了将接口指标设置为 1。只要确保它比你的主适配器小。\n在我和一个伙伴做了这些改变之后，我们立刻找到了彼此，终于可以一起玩了🎉。\n","categories":["工具"],"tags":["Zerotier"]},{"title":"zerotier虚拟局域网联机教程","url":"/2022/05/30/2022-05-30-zerotier%E6%8E%A7%E5%88%B6%E5%99%A8%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/","content":"最近和朋友一起玩无主之地3，因为亚洲的服务器对于我们来说延迟太高，导致游戏体验非常差（基本没法玩），刚好我发现游戏支持局域网联机，刚好我有一台闲置的服务器，我就在想有没有可能通过服务器把我们连接到一个虚拟的局域网中呢？首先我想到了 VPN（virtual private network），于是我在我的服务器上搭建了openvpn，问题随之而来了，打开 vpn 后所有的流量都通过 openvpn 转发了，而且游戏延迟也非常大。于是我就开始了我的Google之旅，机缘巧合之下我发现了 zerotier ，最终我认为这才是我的梦中情人。\n我是用自托管控制器的方式来使用zerotier，因为我想如果内网穿透不成功的话，通过我的服务器进行流量转发延迟和速度会比用官方提供的服务器快一些。\n控制器部署教程安装\n如果你没有在你的服务器上安装zerotier那么你需要先安装它\ncurl -s https://install.zerotier.com | sudo bash\n\nTOKEN\n然后我们设置一个环境变量来记住你节点的令牌（如果你不知道什么是环境变量，你可以认为后面所有的命令中的类似$&#123;TOKEN&#125;都会替换成我们现在配置的值）\nTOKEN=$(sudo cat /var/lib/zerotier-one/authtoken.secret)\n\n\nZeroTier 主目录中的 authtoken.secret 文件是对控制器服务进行 API 调用所必需的，你的 TOKEN 就保存在这里面，如果你想，你可以修改它。\n\nNode ID\n接下来我们要找到服务器上 zerotier 的 Node ID, 因为我们要使用它来找到我们的服务器\n# （可能需要 sudo）zerotier-cli info# 或者你也可以使用curl &quot;http://localhost:9993/status&quot; -H &quot;X-ZT1-AUTH: $&#123;TOKEN&#125;&quot;\n\n在输出的内容中有 “Address” 那一行的内容就是你的 Node ID，复制出来然后我们把它存到环境变量里备用。\nNODEID=你的Node ID\n\n或者如果你觉得上面的太麻烦，你也可以尝试尝试：\nNODEID=$(zerotier-cli info | cut -d &quot; &quot; -f 3)\n\n创建网络\n开始创建我们的虚拟局域网，我们先执行下面的命令来创建一个虚拟局域网。\ncurl -X POST &quot;http://localhost:9993/controller/network/$&#123;NODEID&#125;______&quot; -H &quot;X-ZT1-AUTH: $&#123;TOKEN&#125;&quot; -d &#123;&#125;\n\n执行命令后，在输出的内容中你可以找到 NWID，它的值就是我们要找的。让我们把它写进环境变量备用。\nNWID=你的NWID\n\n邀请小伙伴\n🎉成功执行完成上面这些内容，说明你搭建完成你自己的zerotier控制器了，让你的小伙伴打开zerotier的客户端（如果你还没有下载，去https://www.zerotier.com/download/下载），输入你的 Node ID 点击 Join Network就可以成功的加入到你的网络了，同样你也要加入到这个网络，但是现在你们还不能在局域网中找到对方的电脑，让我们继续下一步，为节点授权。\n授权节点\n先把伙伴的 ID 存到环境变量中，方便后面使用\nMEMID=小伙伴或要授权的ID（就在软件的左上角）\n\n你可以调用接口查看有哪些节点加入到你的虚拟局域网中，这样你就可以确认是否你的小伙伴真的加入到了你的虚拟局域网中。\ncurl &quot;http://localhost:9993/controller/network/$&#123;NWID&#125;/member/$&#123;MEMID&#125;&quot; -H &quot;X-ZT1-AUTH: $&#123;TOKEN&#125;&quot; \n\nOK，确认他加入进来了之后，给他的节点授权，\ncurl -X POST &quot;http://localhost:9993/controller/network/$&#123;NWID&#125;/member/$&#123;MEMID&#125;&quot; -H &quot;X-ZT1-AUTH: $&#123;TOKEN&#125;&quot; -d &#x27;&#123;&quot;authorized&quot;: true&#125;&#x27;\n\n同样我们也需要给自己授权，重新执行上面的3条命令，把MEMID的值换成你自己的ID，给你自己的游戏机（windows）授权。\n至此你已经和小伙伴在同一个虚拟局域网中了。\n\n如果在游戏中不能看到对方，试试FAQ中的第一个解决方案。\n\nFAQ\n我和小伙伴已经可以相互ping通了，但是游戏中的局域网却搜索不到？\n这是因为 BL3 在扫描 LAN 游戏时没有查看正确的适配器。例如，它查看的是普通的 Internet 适配器，而不是虚拟网络适配器。说人话就是虽然你们在一个虚拟局域网中，但是游戏扫描的是 “真实的局域网”，这个时候我们要让它优先扫描虚拟局域网，在我的zerotier局域网游戏无法搜到游戏房间文章中有解决方案\n\n如何查看服务器下所有的NWID？\n查看目录/var/lib/zerotier-one/controller.d/network下的文件，会有对应的NWID的文件。\n\n\n","categories":["工具"],"tags":["zerotier"]},{"title":"计算机基础知识","url":"/2022/08/03/2022-08-03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A6%81/","content":"操作系统是计算机系统中的核心系统软件，负责管理和控制计算机系统中硬件和软件资源，有效的组织和利用计算机的资源。操作系统的特征：并发性、共享性、虚拟性和不确定性。操作系统的功能：进程管理、文件管理、存储管理、设备管理和作业管理。\n经典的操作系统主要分为：1、批处理操作系统，其主要特征为用户脱机使用计算机、成批处理、多道程序运行。2、时分操作系统，其主要特征为交互性、多用户同时性、独立性。3、实时操作系统，其主要特征为提供及时响应和高可靠性。4、网络操作系统，其主要特征为互操作性，写作处理。5、分布式操作系统，分布式操作系统要求有个统一的操作系统，实现系统的操作统一性，负责全系统的资源分配和调度，为用户提供统一的界面。\n进程，操作系统中进程是系统资源分配、调度和管理的最小单位。从静态的观点看，进程由程序、数据和进程控制快（PCB）做成；从动态的观点看，进程是计算机状态的一个有序集合。进程控制快（PCB）是进程存在的唯一标志，描述了进程的基本情况，其中包括：调度信息和执行信息，PCB的存储方式有：线性方式、链接方式和索引方式。\n进程的状态，一个进程从创建而产生至销毁而消亡的整个生命周期，可以用一组状态加以刻画。三态模型：运行态、就绪态、等待态。五态模型\n信号量和PV操作，在操作系统中，进程之间经常会存在互斥（都需要共享独占性的资源时）和同步（完成异步的两个进程协作）两种关系。信号量和PV操作的提出就是为了有效的处理这两种情况。\n\n信号量：是一个变量，可以理解为可用资源的数量和等待队列。\nP操作：分配资源给进程，当没有资源分配时，进程进入等待队列。\nV操作：归还资源，如果等待队列中有进程时，唤醒第一个进程。\n\n地址重定位是指将程序中的虚拟地址（逻辑地址）转换成内存的真实地址（物理地址）的过程。\n\n静态重定位：绝对地址&#x3D;相对地址+程序存放的内存起始地址\n动态重定位：绝对地址&#x3D;重定位寄存器的值（BR）+逻辑地址寄存器\n\n存储管理的主要目的是解决多个用户使用主存的问题。\n\n分区管理：把主存的用户去划分成若干的区域，每一个区域分配给一个用户作业使用，并限定他们只能在自己的区域中使用。分划分为：可重定位分区、可变分区、固定分区。\n分页存储管理：将一个进程的地址空间划分为若干个大小相等的区域，称为页。相应的，将主存空间划分为与页大小相同的若干个物理快，称为块或页框。\n分段管理：分段式存储管理系统中，为每个段分撇一个连续的分区，而进程中的各个段可以离散的分配到主存的不同分区中。\n段页式存储：段页式系统的基本原理是先讲整个主存划分成大小相等的存储块（页框），将用户程序按程序逻辑关系氛围若干个段，再将每个段划分为若干个页，以页框为单位离散分配。\n虚拟存储。\n\n管程和线程。线程是进程的活动成分，是处理器分配资源的最小单位。\n死锁。死锁是指多个进程之间互相等待对方的资源，而在得到对方资源之前又不释放自己的资源，造成循环等待的一种现象。如果一个进程在等待一个不可能发生的事件则进程就死锁了。发生死锁的必要条件有：互斥条件、请求保持条件、不可剥夺条件、环路条件\n银行家算法是指在分配资源之前先看清楚分配资源后是否会造成导致系统死锁。如果会死锁，则不分配；否则就分配。\n\n当一个进程对资源的最大需求量不超过系统中的资源数时，可以接纳该进程。\n进程可以分期请求资源，但请求的总数不能超过最大需求量。\n当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间内得到资源。\n当系统现有的资源能满足进程尚需资源数时，必须测试系统现存的资源数能否满足该进程尚需的最大资源数，若能满足则按当前的申请量分配资源；否则也要推迟分配。\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"操作系统梳理","url":"/2022/08/05/2022-08-05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/","content":"操作系统的类型与结构根据使用环境对作业的处理方式，操作系统可以分为批处理操作系统、分时操作系统、实时操作系统、网络操作系统和分布式操作系统。\n操作系统的结构可以分为无序结构、层次结构、面向对象结构、对称多处理结构和微内核结构。\n\n无需结构以大型表格和队列为中心，操作系统的各个部分程序围绕着表哥运行，整个系统就是一个程序。\n层次结构是把一个大型复杂的操作系统分解成若干个单向依赖的程次，由多层的正确性保证操作系统的可靠性。\n面向对象结构是基于面向对象程序设计的编程理念，采用了各种不同的对象技术。\n对称多处理结构。如果一个操作系统在系统中的所有处理机运行且共享同一内存这样的系统就是一个对称多处理系统。\n微内核结构是把系统的公共部分抽象出来，形成一个底层的核心，提供最基本的服务，其他功能都以服务的形式建立在微内核之上。\n\n现代操作系统大多拥有两种工作状态：核心态和用户态。我们使用的一般程序工作在用户态，而内核模块和基本的操作系统核心工作在核心态。\n处理器管理进程是一个程序关于某个数据集的一次运行。进程是程序的一次运行活动，是一个动态的概念，而程序是静态的概念，是指令的集合。进程具有动态性和并发性，程序是进程运行所对应的运行代码，一个进程对应一个程序，一个程序可以同时对应多个进程。在操作系统中进程是进行系统资源分配、调度和管理的最小单位（注意，现代操作系统中还引入了线程这一概念，它是处理器分配资源的最小单位）。从静态观点看，进程由程序、数据和进程控制块（PCB）组成；从动态的观点看，进程是计算机状态的一个有序集合。\nPCB是进程存在的唯一标识，PCB描述了进程的基本情况。其中的内容可以分成为调度信息和执行信息两大部分。\n一个进程从创建而产生至撤销而消亡的整个生命周期，可以用一组状态加以刻画，为了便于管理进程，把进程划分为几种状态，分别由三态模型和五态模型。\n\n\n信号量和PV操作，是为了有效的处理进程之间经常会存在互斥和同步两种关系。\n死锁是指多个进程之间会想等待对方的资源，而在得到对方资源之前又不释放自己的资源，这样，造成了循环等待的一种现象。发生死锁的必要条件有：互斥条件、请求保持条件、不可剥夺条件、环路条件。\n银行家算法就是为了解决死锁，其在分配资源之前先看清楚资源分配之后是否会导致系统死锁。如果会死锁，则不分配，否则就分配。\n解决死锁的策略主要有：死锁预防、死锁避免、死锁检测、死锁解除。\n文件管理文件的逻辑组织是为了方便用户的使用，逻辑结构是用户可见的结构。常用的记录式结构有连续结构、多重结构、转制结构和顺序结构。\n文件的物理结构是指文件在存储设备上的存储方法，常用的文件物理结构有连续文件、串联文件和索引文件。\n由于文件存储设备式分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设别的管理，实质上是对空闲块的组织和管理问题，它包括空闲块的组织、空闲块的分配与空闲块的回收等问题。空闲表法、空闲链法和位图法。\n存储管理\n在虚拟存储器的管理中，涉及载入（调入）、放置（放入分区）和置换等问题。\n\n调入策略：即合适将以页或一段从外存中调入内存，通常有两种策略，一种是请求调入法，即需要使用时才调入；另一种是先行调入法，即将预计要使用的页&#x2F;段先行调入内存。\n放置策略：也就是调入喉，放在内存的什么位置，这与内存管理基本是一致的。\n置换策略：由于实际内存是小于虚拟内存的，因此可能会发生内存已满，但需要使用的页不存在内存这一种情况（称缺页中断）。这时就需要进行置换，即将一些内存中的页淘汰到外存，腾出空间给要使用的页，这个过程也称为交换。\n\n常见的置换算法有：最有算法、随机算法、先进先出和最近最少使用算法。\n存储管理策略的基础是 局部性原理，即进程往往会不均匀地高度局部变化地访问内存。局部性分为时间局部性和空间局部性。时间局部性是指最近访问的存储位置，很可能在不久的将来还要访问；空间局部性是指存储访问又成组的倾向：当访问某个位置后，很可能也要访问其附近的位置。\n作业管理作业调度主要完成从后备状态到执行状态的转变，以及执行状态到完成状态的转变。作业调度算法有：先来先服务、短作业优先、响应比高者优先和优先级调度。\n设备管理在计算机系统中，除了处理器和内存之外，其他大部分硬件设备称为外部设备。他们主要提供的功能有：提供和进程管理系统的接口；进行设备分配；实现设备和设备、设备和CPU等之间的并行操作；进行缓冲区管理。\n在计算机中，输入输出系统可以有 5 种不同的工作方式，分别是程序控制方式、程序中断方式、DMA（Direct Memory Access，直接内存存取）工作方式、通道方式、输入&#x2F;输出处理机。\n磁盘调度算法，访问磁盘的是时间由3部分构成，它们是寻道（查找数据所在的磁道）时间，等待（旋转等待扇区）时间和数据传输时间，其中寻道时间（查找时间）是决定因素。\n\nFCFS 算法，也称为FIFO算法。\nSSTF算法，最短寻道时间优先。\nSCAN算法，电梯算法。\nN-SCAN算法，N步SCAN算法。\nC-SCAN算法，循环扫描算法。\n\n操作系统结构\n","categories":["软考"],"tags":["软考 基础"]},{"title":"我的软考系统架构设计师查漏补缺","url":"/2022/08/06/2022-08-06-%E6%88%91%E7%9A%84%E8%BD%AF%E8%80%83%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/","content":"\n采用微内核的操作系统提高了系统的灵活性和扩展性，并增强了系统的可靠性和可移植性，可运行于分布式系统\n\n在设计微内核OS时，采用了面向对象的技术，其中的“封装”，“继承”，“对象类“和多态性”，以及在对象之间采用消息传递机制等，都十分有利于提高系统的“正确性”、”可靠性“、”易修改性“、”易扩展性“等，而且还能显著的减少开发系统所付出的开销。采用微内核结构的操作系统与传统的操作系统相比，其优点是提高了系统的灵活性、可扩展性，增强了系统的可靠性，提供了对分布式系统的支持。\n ①灵活性和可扩展性：由于微内核OS的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核OS只需在相应的服务器中增加新的功能，或再增加一个专门的服务器。与此同时，也必然改善系统的灵活性，不仅可在操作系统中增加新的功能，还可修改原有功能，以及删除已过时的功能，以形成一个更为精干有效的操作系统。\n ②增强了系统的可靠性和可移植性：由于微内核是出于精心设计和严格测试的，容易保证其正确性；另一方面是它提供了规范而精简的应用程序接口（API），为微内核 外部的程序编制高质量的代码创造了条件。此外，由于所有服务器都是运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，当某个服务器出现错误时，不会影响内核，也不会影响其他服务器。另外，由于在微内核结构的操作系统中，所有与特定CPU和I&#x2F;O设备硬件有关的代码，均放在内核和内核下面的硬件隐藏层中，而操作系统其他绝大部分（即各种服务器）均与硬件平台无关，因而，把操作系统移植到另一个计算机硬件平台上所需作的修改是比较小的。\n③提供了对分布式系统的支持：由于在微内核OS中，客户和服务器之间以及服务器和服务器之间的通信，是采用消息传递通信机制进行的，致使微内核OS能很好地支持分布式系统和网络系统。事实上，只要在分布式系统中赋予所有进程和服务器唯一的标识符，在微内核中再配置一张系统映射表（即进程和服务器的标识符与它们所驻留的机器之间的对应表），在进行客户与服务器通信时，只需在所发送的消息中标上发送进程和接收进程的标识符，微内核便可利用系统映射表将消息发往目标，而无论目标是驻留在哪台机器上。      \n\n\n操作系统为用户提供了两类接口：操作一级的接口和程序控制一级的接口。其中，操作一级的接口包括操作控制命令、菜单命令等；程序控制一级接口包括系统调用。\n\n在磁盘调度管理中，应先进行移臂调度，再进行旋转调度。\n\n先进行移臂（对应“柱面”）调度，再进行旋转（对应“磁头、扇区”）调度。\n\n\n若进程A的逻辑页4与进程B的逻辑页5要共享的物理页8,那么应该在进程A页表的逻辑页4对应的物理页处填8,进程B页表的逻辑页5对应的物理页处也填8。\n\n进入临界区时执行P操作，退出临界区时执行V操作。\n\nPCI（Peripheral ComponentInt Interconnect）总线标准是一种局部并行总线标准，常用来表示个人计算机中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。\n\n\n  GUI（Graphical User Interface）常用来表示采用图形方式显示的计算机操作用户界面。\n  API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，开发人员无须访问源码（或理解内部工作机制的细节）。\n\n给定段地址（x，y），其中：x为段号，y为段内地址。将（x，y）转换为物理地址的方法是：根据段号;c查段表一判断段长；如果小于段长，则物理地址&#x3D;基地址-段内地址y，否则地址越界。\n\n在索引文件结构中，二级间接索引是指：索引结点对应的盘块存索引表，在索引表指向的盘块中依然存索引表，由于每个索引表可以存4K&#x2F;4&#x3D;1024个块号，所以二级索引可对应1024*1024个物理块。\n\n实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行的操作系统。因而，提供及时响应和高可靠性是其主要特点。实时操作系统有硬实时和软实时之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可。 实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。 事实上，实时操作系统如同操作系统一样，就是一个后台的支撑程序，能针对硬件变化进行结构与功能上的配置、裁剪等。其关注的重点在于任务完成的时间是否能够满足要求。\n\n串行总线的特点如下。\n\n串行总线由半双工和全双工之分。\n串行总线适宜长距离传输数据。\n串行总线按（bit）发送和接收，尽管较按字节（byte）的并行通信满，但是串口可以在使用一条线发送数据的同时用另一条线接受数据。它很简单并能够实现远距离通信，如 IEEE488 定义并行通信状态时，规定设备线总线长不得超过 20 米，并且任意两种设备间的连接长度不得超过 2 米。而对于串口而言，长度可达 1200 米。\n串口通信最重要的参数时波特率、数据位、停止位和奇偶校验，对于两个进行通信的端口，这些参数必须匹配。\n串行总线的数据发送和接收可以使用多种方式，其中中断方式和 DMA 较为常见。\n\n\n软件设计层面的工号控制可以从以下几个方面展开。\n\n软硬件协同设计，即软件的设计要与硬件的匹配，考虑硬件因素。\n编译优化，采用低功耗优化的编译技术。\n减少系统的持续运行时间，可以从算法角度进行优化。\n用中断代替查询。\n进行电源的有效管理。\n\n\nCPU 的工作频率（主频） &#x3D; 外频 × 倍频。外频就是外部频率，指的是系统总线的频率。倍频的全称是“倍频系数”，是指 CPU 主频与外频之间的相对比例关系。\n\n最初 CPU 主频和系统总线速度是一样的，但 CPU 的速度越来越快，倍频技术也相应的产生。它的作用是使系统总线工作在相对较低的频率上，而 CPU 速度可以通过倍频来提升。\n\n\n在客户机上运行 nslookup 查询某服务器名称时能解析出 IP 地址， 查询 IP 地址时却不能解析出服务器名称，解决这一问题的方法是为改服务器创建 PTR 记录。\n\nPTR 记录是反向记录，通过 IP 查询域名。 \n\n\nDHCP 客户端收到 DHCP 服务器回应的 ACK 报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送 DhcpDecline 报文通知服务器所分配的 IP 地址不可用。\n\n为了优化系统性能，又是需要对系统进行调整。对于数据库系统，性能调整主要包括CPU&#x2F;内存使用情况、数据库设计、数据库管理、进程&#x2F;线程状态、硬盘剩余空间、查询语句性能、日志文件大小等；对于应用系统，性能调整主要包括应用系统的可用性、响应时间、并发用户数，以及特定应用的系统资源占用等。\n\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"数据库系统梳理","url":"/2022/08/06/2022-08-06-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/","content":"数据库管理系统的类型：数据库管理系统的类型通常有多个分类标准。入按数据模型分类、按用户数分类、按数据库分布站点分类等。\n近几年随着NoSQL技术的兴起，也产生了一些新的数据模型。常见的DBMS按数据模型划分，包括：**关系型DBMS、文档型DBMS、键值型DBMS、对象型DBMS等。\n数据库的结构，由ANSI&#x2F;SPARC数据库系统研究组 1975 年提出的三级划分法。\n\n数据库系统划分为三个抽象级：用户级、概念级、物理级。数据库系统的三级模式为外模式、概念模式、内模式。\n数据库系统两级独立性是指物理独立性和逻辑独立性。三个抽象级通过两级映射进行相互转换，使得数据库的三级形成一个统一的整体。\n数据模型主要有两大类，分别是概念数据模型和基本数据模型。\n\n概念数据模型是按照用户的观点来对数据和信息建模，主要用于数据库设计。概念模型主要是实体–联系方法表示，所以也称E-R模型。\n基本数据模型是按照计算机系统的观点来对数据和信息建模，主要用于DBMS的实现。基本数据模型是数据库系统的核心和基础。基本数据模型通常由数据结构、数据操作和完成性约束三部分组成。其中数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述，完整性约束是一组完整性规则的集合。\n\n常用的基本数据模型由层次模型、网状模型、关系模型和面向对象模型。\n关系代数的基本运算主要有并、交、差、笛卡尔积、选择、投影、连接和除法运算。\n\n未完待续\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"CRC校验原理及步骤","url":"/2022/08/08/2022-08-08-CRC%E6%A0%A1%E9%AA%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%AD%A5%E9%AA%A4/","content":" CRC 校验码即循环冗余校验码，是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。\nCRC校验原理： 其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“模2除法”）。到达接收端后，再把接收到的新帧除以（同样采用“模2除法”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。\nCRC校验码计算\n \n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"23种设计模式（软考）","url":"/2022/08/09/2022-08-09-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/","content":"设计模式的原则。设计模式有六大原则：①单一职责原则；②里氏置换原则；③依赖倒置原则；④接口隔离原则；⑤迪米特原则；⑥开闭原则；\n创建型模式：对对象实例化过程的抽象，通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息。包括以下几种设计模式。\n\n抽象工厂模式：提供创建一组或者一系列相关的相互依赖对象的接口。\n构建器模式：将复杂对象的构件与它的表示分离，使得同样的构建过程可以创造不同的表示。\n工厂方法模式：定义一个用于创建对象的接口，由子类决定实例化那个类的对象。\n原型模式：指定创建对象的种类，并且通过拷贝这些原型创建新的对象。以一个已有的对象作为原型，通过它来创建新的对象。\n单例模式：一个类只有一个实例。\n\n结构型模式：主要用于如何组合已有的类和对象以获得更大的结构，它采用集成机制来组合接口和实现，以提供统一的外部视图或新的功能。\n\n适配器模式：将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n组合模式：将对象组合成树型结构以表示“部分–整体”的层次结构。\n外观模式：位子系统中的一组接口提供一个统一的接口，外观模式通过提供一个高层接口隔离了外部系统与子系统见负载的交互过程，使得复杂的子系统更容易使用。\n享元模式：通过共享对象减少系统中低的能级的，详细的对象数目。\n代理模式：为控制对出事对象的访问，提供了一个代理或者占位符对象。\n\n行为型模式：从大量实际行动中概括出来作为行为的理论抽象、基本框架和标准。该类模式主要用于对象之间的职责及其提供的服务的分配，它不仅描述对象或类的模式，还描述它们之间的通信模式。\n\n责任链模式：在系统中建立一个链，消息可以首先接收它的级别被处理，或者定位带可以处理它的对象。\n命令模式：在对象中封装请求，保存命令并传递给方法以及像任何其他对象一样返回该命令。\n解释器模式：解释定义及其语法表示的语言。\n迭代器模式：提供一种方法顺序地访问一个聚合对象中的各个元素，而又不暴露对该对象的内部表示。\n备忘录模式：保持对象状态的“快照”，在不向外界公开其内容的情况下返回它的最初状态。\n观察者模式：为组件向相关接收方广播消息提供了灵活的方法。\n状态模式：允许对象在内部状态变化时变更其行为，并且修改其类。\n策略模式：定义了一组用来表示可能行为集合的类。\n模版方法模式：提供了在不重写方法的前提下允许子类重载部分方法的方法。\n访问者模式：提供了一种方便的、可维护的方法来表示在对象结构元素上进行的操作。该模式允许在不改变操作元素的前提下定义一个新操作。\n中介者模式：功过引入一个能够管理对象间消息分布的对象，简化了系统对象的通信。\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"系统性能（软考）","url":"/2022/08/12/2022-08-12-%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/","content":"计算机性能指标：主要性能指标有时钟频率（主频）、运算速度、运算精度、内存的存储容量、存储器的存取周期、数据处理速率；吞吐率、各种响应时间、各种利用率、RASIS特性，即可靠性、可用性、可维护性、完整性和安全性；平均故障响应时间、兼容性、可扩充性、性能性价比。\n路由器的性能指标：主要的性能指标有设备吞吐量、端口吞吐量、全双工线速转发能力、背靠背帧数、路由表能力、背板能力、丢包率、时延、时延抖动、VPN支持能力、内部时钟精度、队列管理机制、端口硬件队列数、分类业务带宽保证、RSVP、IP Diff Serv、CAR支持、冗余、热插拔组件、路由器冗余设计、网管、基于Web的管理、网管类型、带外网管支持、网管粒度、计费能力&#x2F;协议、分组语言支持方式、协议支持、语音压缩能力、端口密度、信令支持。\n交换机性能指标：主要性能指标有交换机类型、配置、支持的网络类型、最大 ATM 端口数、最大 SONET 端口数、最大 FDDI 端口数、背板吞吐量、缓冲区大小、最大MAC地址大小、最大电源数、支持协议和标准、路由信息协议、开放式最短路径优先、边界网关协议、无类别域间路由、互联网成组管理协议、距离矢量多播路由协议、开放式最短路径优先多播路由协议、协议无关的多播协议、资源预留协议、802.1p优先级标记，多队列、路由、支持第3层交换、支持多层（4到7层交换、支持多协议路由、支持路由缓存、可支持最大路由表数、VLAN、最大VLAN数量、网管、支持网管类型、支持端口镜像、QoS、支持基于策略的第2层交换、每端口最大优先级队列数、支持基于策略的第三层交换、支持基于策略的第二层交换、每端口最大优先级队列数、支持基于策略的第三层交换、支持基于策略的应用级QoS、支持最小&#x2F;最大带框分配、冗余、热交换组件。\n网络性能指标：主要指标有设备级别性能指标、网络级性能指标、应用级性能指标、用户级性能指标。\n操作系统性能指标：主要性能指标有系统的可靠性、系统的吞吐率、系统响应时间、系统资源利用率、可移植性。\n数据库管理系统：主要性能指标有数据库大小、数据库表中的数量、单个表的大小、表中允许的记录数量、单个记录的大小、表上所允许的索引数量、数据库的所允许的索引数量、最大兵法事务处理能力、负载均衡能力、最大连接数等等。\nWeb服务器：主要性能指标有最大并发连接数、响应延迟、吞吐量。\n","categories":["软考"],"tags":["软考 基础"]},{"title":"信息系统基础知识（软考）","url":"/2022/08/14/2022-08-14-%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/","content":"用于企业信息系统规划的方法甚多，主要是关键成功因素法、战略目标集转移法和企业系统规划法。含有企业信息分析与集成技术、产出&#x2F;方法分析、投资回收方法、证费法、零线预算法。用的最多的是前三种方法。\n\n关键成功因素法\n在现行的系统中，总存在着多个变量影响系统目标的实现，其中若干个因素是关键的和主要的（即关键成功因素）。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。\n关键成功因素来自于组织的目标，通过组织的目标分解和关机成功因素识别、性能指标识别，一致到产生数据字典。\n识别关键成功因素，就是要识别联系于组织目标的主要数据类型和关系。不同的组织，关键成功因素不同；不同时期，关键成功因素也不同。当在一个时期内的关键成功因素解决后，新的识别关键成功因素又开始。\n关键成功因素法能抓住主要的矛盾，是目标的识别突出重点。由于经理们对使用这种方法确定目的比较熟悉，因而经理们乐于努力去实现。该方法是最有利于确定企业的管理目标。\n\n战略目标集转化法\n把整个战略目标看作一个“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程就是把组织的战略目标转变成为管理信息系统的战略目标的过程。\n战略目标集转化法从另一个角度识别目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统的结构化方法。它能保证目标比较全面、疏漏较少，但在突出重点方面不如关键成功因素法。\n\n企业系统规划法\n信息支持企业运行。自上而下的识别系统目标，企业过程和数据，然后对数据进行分析，自下而上的设计信息系统。该管理信息系统支持企业目标的实现，表达所有管理层次的要求，想企业提供一致性信息，对组织机构的变动有适应性。\n企业系统规划法虽然也首先强调目标，但它没有明确的目标引导过程。它通过识别企业“过程”引出系统目标，企业目标到系统目标的转化是通过企业过程&#x2F;数据类等矩阵的分析得到的。\n\n\n一般来说，信息话需求包含三个层次，即战略需求、运作需求和技术需求。\n\n战略需求。组织信息化的目标是提升组织的竞争力，为组织的可持续发展提供一个支持环境。从某种意义上来说，信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具，信息化可以把组织战略提升到一个新水平，为组织带来新的发展契机。特别是对于企业，信息化战略是企业竞争的基础。\n运作需求。组织信息化的运作需求是组织信息化需求非常重要且关键的一环，他饱含三个方面的内容：一是实现系信息化战略目标的需要；二是运作策略的需要；三是人才培养的需要。\n技术需求。由于系统开发时间过长等问题，在信息技术层面上对系统的完善、升级、集成和整合提出了需求。有的组织原来基本上没有大型的信息项目系统，有的也只有过一些单机应用项目，这样的组织信息化需求一般是从头开发新的系统。\n\n企业应用集成通过采用多种集成模式，构建统一标准的基础平台，将具有不同功能和目的而又独立运行的企业信息系统联合起来。目前市场上主流的集成模式有三种：面向信息的集成、面向过程的集成和面向服务的集成。\n企业门户可以划分为四类：企业网站、企业信息门户、企业知识门户和企业应用门户。\n客户关系管理系统将市场营销的科学管理理念通过信息技术的手段集成到软件上，能够帮助企业构建良好的客户关系。在客户管理系统中，销售自动化是其中最为基本的模块；营销自动化作为销售自动化的补充，表扩营销计划的编制和执行、计划结果分析等国内功能。客户服务与支持是CRM系统的重要功能。客服服务与支持的主要手段有两种：呼叫中心和互联网。CRM系统能够与ERP系统在财务、制造、库存等环节进行连接，两者之间虽然关系比较独立，但由于两者之间具有一定的关系，因此会形成一定的闭环反馈结构。\n","categories":["软考"],"tags":["软考 基础"]},{"title":"软件开发模型（软考）","url":"/2022/08/15/2022-08-15-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/","content":"软件生存周期又称软件开发模型或软件过程模型，它是从某一个特定角度提出的软件过程的简化描述。模型的主要特点是简单化。软件过程模型是软件开发世纪过程的抽象与概括，它应该是包括构成软件过程的各种活动，也就是对软件开发过程各个阶段之间关系的一个描述和表示。\n软件过程模型的基本概念：软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，软件活动主要有如下一些：\n\n软件描述。必须定义软件功能以及使用限制。\n软件开发。也就是软件设计和实现，软件工程人员制作出满足描述的软件。\n软件有效性验证。软件必须经过严格的验证，以保证能满足客户的需求。\n软件进化。软件随着客户需求的变化不断改进。\n\n软件过程模型是软件工程的重要内容，它为软件工程管理提供里程碑和进度表，为软件开发过程提供原则和方法。软件过程为各种各样的模型，如瀑布模型、演化模型、原型模型、螺旋模型、喷泉模型和基于可重用构建的模型等。以下介绍主要的几种：\n\n瀑布模型可以说好似最早使用的软件生存周期模型之一。特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建筑在前一个阶段正确结果之上，前一个阶段的错漏会隐蔽的带到后一个阶段。\n原型模型又称快速模型。主要有两个阶段：原型开发阶段，软件开发人员根据用户的提出的系统的定义，快速地开发一个原型。目标软件开发阶段，在征求用户对原型的意见后对原型进行修改完善，确认软件系统的需求并表达一致的理解，进一步开发实际的系统。\n螺旋模型。它把整个软件开发流程分成多个阶段，每一个阶段都由4部分组成，它们是：目标设定、风险分析、开发和有效性验证、评审。\n基于可重用构件的模型\n基于面向对象的模型\n基于四代技术的模型\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"LCU websocket 入门使用教程","url":"/2022/09/23/2022-09-23-LCU-websocket-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"\n新版本的国服英雄联盟客户端已经不能连接LCU接口了\n\n除了 LCU REST API，League 客户端架构还使用 websocket 连接将更改从 LCU 本身传送到要显示给你的 UX 流程（例如，你收到的好友请求或聊天消息）。本指南将向你展示如何连接到此 websocket 并请求有关状态更改的通知。这篇文章假定你具备 LCU API 的基本知识。LCU websocket 在这个 websocket 上使用 WAMP 1.0 协议。\n\n新版本的国服英雄联盟客户端已经不能连接LCU接口了 – 2022-10-20更新之后，后续不知道会不会开放。\n\n连接到Websocket有了手中的密码和端口，这应该就像告诉 websocket 客户端&#x2F;库连接到wss://127.0.0.1:12345/。 但要注意的是，你仍然必须像调用 LCU REST API 端点一样在请求Header中传入 authorization 字段。\n如果连接成功，它应该保持打开状态而没有任何响应，如果出现任何问题，你获得的唯一信息是 HTTP 响应代码，但可能无法连接，唯一原因是你没有正确的配置Header。\n与 websocket 通信WAMP 1.0 对每条消息都使用 JSON 数组。数组的第一项始终是操作码。5为你订阅一个事件，为6你取消订阅一个事件，并且8是客户端在向你发送事件时将使用的操作码。\n订阅事件为了订阅一个事件，你需要发送一个第一个索引为 5 的 JSON 数组，订阅方法的操作码和一个字符串的第二个索引，告诉 LCU 你想订阅哪个事件。\n例如，发送[5, &quot;OnJsonApiEvent&quot;]将使你订阅客户端发送的每个事件。如需更完整的事件列表，你可以调用/help客户端提供的端点，OnJsonApiEvent将订阅你每个可用的事件。\n退订事件这就像订阅一样简单，发送一个数组，第一个索引为 6，第二个索引是你要取消订阅的事件的名称，例如：[6, &quot;OnJsonApiEvent&quot;]\n请记住，你不能订阅 OnJsonApiEvent 然后取消订阅你不感兴趣的较小事件。你必须首先订阅较小的事件。\n接收更新接收更新有点不同。数组的前 2 个索引与以前相同，8 将是操作码，第二项将是事件的名称，第三项将是具有 3 个条目的 JSON blob data，eventType和uri。\n\nuri 将告诉你更改的确切路径（对于包含标识符的聊天等事件可能很有用）\neventType 将让你知道在该路径上发生的操作 ( Create, Update, )Delete\n数据 100% 特定于事件，但它们通常遵循各自 LCU 端点使用的相同结构\n\n这是一个例子：\n[8,”OnJsonApiEvent”,{“data”:[],”eventType”:”Update”,”uri”:”&#x2F;lol-ranked&#x2F;v1&#x2F;notifications”}]\n请记住，如果你订阅了两个OnJsonApiEvent事件和相应的较小事件，你将收到两次事件，因此请小心。\n结论就这么多！有了这些知识，与定期轮询 LCU API 相比，你应该能够更轻松地构建响应式应用程序。\n","categories":["技术"],"tags":["LCU 英雄联盟"]},{"title":"UML建模与架构文档化（软考）","url":"/2022/08/24/2022-08-24-UML%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/","content":"UML的四种类型图特点及对应的视图。\n用例图：从外部用户角度描述系统功能，并指出功能执行者。\n静态图：显示了系统的静态结构，特别是存在事物的种类的内部结构相互之间的关系，包括类图、对象图、包图。\n行为图：描述系统的动态模型和组成对象间的交互关系，包括交互图、状态图、活动图。\n实现图：描述软件实现系统的组成和分布状况，包括构建图和部署图。\n\n\n\n类图：类与类之间的关系：关联、聚集、组合、泛化和依赖。\n对象图：表示再摸一时刻一组对象及其之间的关系，可以看做类图在系统某一时刻的实力。\n包图：是一种维护和描述系统总体结构的模型的重要建模工具，描述系统的分解结构，表示包和包之间的关系，展现系统模块之间的依赖关系。\n交互图：买哦数对象之间的消息传递，包括：顺序图，又称时序图，用于显示对象之间的交互；协作图，描述系统的行为。\n状态图：对类图的补充，一个对象在其生命期的动态行为。\n活动图：系统的工作图和并发行为。\n构件图：一组构件及其之间的相互关系。\n部署图：也成配置图、实施图，可以用来显示系统中计算节点的拓扑结构和通信路径与节点上运行的软件构件等，用于理解分布式系统。\n\nUML软件开发过程\n基于UML进行需求分析。从业务需求描述出发获取执行者和场景，对场景进行汇总、分类、抽象，形成用例，确定执行者和用例、用例和用例之间的关系，生成用例图。\n面向对象的设计。设计用例的步骤：\n提取边界类、实体类和控制类。\n构造交互图。\n根据交互图精化类图。\n\n\n\n系统结构文档化“4+1”视图包括：逻辑是图、过程视图、物理视图、开发视图、场景。\n逻辑架构：设计的对象模型（使用面向对象的设计方法时）。支持功能性需求，采用抽象、封装或继承的原理，用来识别遍布系统各个部分的通用机制和设计元素。\n进程架构：捕捉设计的并发和同步特征。考虑一些非功能性的需求，如性能和可用性。在几种层次的抽象上进行描述，每格层次针对不同问题。\n开发架构：描述开发环境中软件的静态组织结构。用模块和子系统来表达，显示了“输入”和”输出“的关系。\n物理架构：描述了软件到硬件的映射，反映了分布式特性。主要关注系统非功能性需求，可用性、可靠性、性能和可伸缩性。\n场景：架构的描述，即所作的各种决定，可以围绕着这四个视图来组织，软后由一些用例或场景来说明，从而形成了第五个视图。\n补充\n在实际工作中，一般使用E-R图表示数据模型，用DFD表示功能模型，用状态转换图表示行为模型。\n基于架构的软件开发（ABSD）强调由商业、质量和功能需求的组合驱动软件架构设计。他强调采用视角和视图来描述软件架构，采用用例和质量场景来描述需求。\n\n","categories":["软考"],"tags":["软考 基础"]},{"title":"Java面试","url":"/2022/10/14/2022-10-14-interview/","content":"工作的时候很多东西是用不到的，这不，等到再面试的时候，本应该掌握的东西有些又被大风吹走了😂，八股文还是得搞一搞。\nJVMJVM内存模型\n从 JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n\n线程私有\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\nJava 虚拟机栈也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。\n\n局部变量表 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。\n动态链接 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。\n\n本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n线程共享\n堆是Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\n多线程volatile\nvolatile 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 volatile 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\nvolatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\n在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\nsynchronized\n\nsynchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；\nsynchronized 关键字加到实例方法上是给对象实例上锁；\n尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能。\n\n垃圾回收标记-清除法：效率低，标记清除后会有大量的的碎片。\n标记-复制法：空间利用率低。\n标记-整理法：类似标记清除，但会整理也就没有碎片。\n分代收集：新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n数据库数据库优化 \n选取最适用的字段属性、使用连接（JOIN）来代替子查询(Sub-Queries)、使用联合(UNION)来代替手动创建的临时表、事务、锁定表、使用外键、使用索引、优化的查询语句\n数据库设计的步骤\n\n需求分析 : 分析用户的需求，包括数据、功能和性能需求。\n概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。\n逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。\n数据库实施 : 包括编程、测试和试运行\n数据库的运行和维护 : 系统的运行与数据库的日常维护\n\n数据库事务\n事务是逻辑上的一组操作，要么都执行，要么都不执行。\n事务都有 ACID 特性：只有保证了事务的持久性D、原子性A、隔离性I之后，一致性C才能得到保障。\n事务的传播机制\n 多个事务的方法相互调用时Spring提供的7中不同的传播特性，保证事务的正常执行。\n并发事务带来的问题\n脏读，修改丢失，不可重复读，幻读。\n数据库的隔离级别\n\nREAD-UNCOMMITTED(读取未提交) \nREAD-COMMITTED(读取已提交)\nREPEATABLE-READ(可重复读)  – 默认隔离级别\nSERIALIZABLE(可串行化)\n\nRedis 和 RabbitMQRedis 中的数据类型： String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）、HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)、Stream（5.0后，可以做消息队列，但消息丢失和堆积问题不好解决）\nRedis 事务（没有rollback不建议使用）\nMULTI 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令后，再执行所有的命令。\nDISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令\nWATCH 命令监听指定的 Key，当调用 EXEC 命令执行事务时，如果一个被 WATCH 命令监视的 Key 被 其他客户端&#x2F;Session 修改的话，整个事务都不会被执行。\n常用的设计模式软件设计原则：\n\n\n工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。\n代理设计模式 : Spring AOP 功能的实现。\n单例设计模式 : Spring 中的 Bean 默认都是单例的。\n模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\n包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\n观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。\n适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。\n\n","categories":["技术"],"tags":["Java 面试"]},{"title":"（转载）破解移动光猫吉比特--H2-3","url":"/2022/10/27/2022-10-27-%5B%E8%BD%AC%E8%BD%BD%5D%E7%A0%B4%E8%A7%A3%E7%A7%BB%E5%8A%A8%E5%85%89%E7%8C%AB%E5%90%89%E6%AF%94%E7%89%B9--H2-3/","content":"\n本文作者： guaosi本文链接： https://www.guaosi.com/2019/03/09/crack-china-mobile-optical-modem-h2-3/版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议  进行许可。转载请注明出处！\n\n1. 起因​    过年期间家里装了2年免费的移动光纤(真香)，可是移动装机默认光猫都是路由模式，装机师傅以及移动人工客服都是拒绝给超级账户的。所以只能自己想办法解决。\n2. 解决办法1.工信部投诉，百试百灵2.淘宝或者闲鱼花钱让别人破解(我查了貌似没有这个型号)3.手摸手自己折腾自己搞\n3. 优点破解后的好处:1.可以将光猫变成桥接模式，然后用自己的路由器拨号，更稳定。2.对光猫h2-3有完全控制能力，可以使用全部功能。破解后的界面图如下:\n4. 准备1.一台确认已经开启telnet的电脑\n2.一台正常可用的主人公h2-3光猫\n3.知道光猫的普通账户的账号密码(在光猫后面贴着)\n4.确认电脑与光猫在同一局域网内\n5.Firefox浏览器或者Chrome浏览器\n注意:如果想把光猫转成桥接模式，路由器来拨号的话，需要知道宽带密码是多少。如果不知道，建议先打10086人工客服下发重置密码的短信。\n5. 破解过程5.1. 打开光猫telnet1.首先打开浏览器，在扩展中安装HTTP Header Live插件(不知道怎么安装自行百度)。\n2.浏览器打开\nhttp://192.168.1.1\n\n\n\n看到光猫的登陆界面，使用普通账户进行登陆\n3.打开HTTP Header Live插件，在页面上随便点击一个页面，再次查看HTTP Header Live插件，捕捉到了post信息我们需要使用它的header头来发送我们的消息，以此来修改光猫telnet的账号密码\n4.点击打开一个post\n修改链接为\nhttp://192.168.1.1/boaform/set_telenet_enabled.cgi\n\n\n\n内容为：\nmode_name=set_telenet_enabled&amp;nonedata=0.3535281170047305&amp;user_name=root&amp;user_password=admin&amp;telenet_enabled=1&amp;default_flag=1\n\n\n\n意思是将光猫的telnet账号密码分别设置为root与admin\n5.然后点击右下角的send确认，会返回一个成功的页面，代表已经成功打开光猫的telnet\n5.2. 登陆光猫telnet\n打开命令行工具，输入\n\ntelnet 192.168.1.1\n\n连接上后，在OpenWrt login提示时输入账号root，在Password提示时输入密码admin，然后回车。即可成功登陆进光猫的telnet\n\n2.切换到配置文件目录\ncd /config/worka\n\n\n\n然后我们查看一下文件\nls -al\n\n\n\n如果使用的是windows的cmd，那么可以使用\ndir\n\n\n\n\n其中，backup_lastgood.xml与lastgood.xml是我们后面需要修改的文件\n5.3. 修改配置文件1.我们查看一下backup_lastgood.xml里面的内容\nvim backup_lastgood.xml\n\n\n\n然后搜索TeleAccountName,就可以看到存放的账号以及密码\n其中，TeleAccountName和TeleAccountPassword分别代表超级账户的账号密码。UserAccountName和UserAccountPassword分别代表普通账户的账号密码。\n2.现在我们来分析一下,UserAccountName的Value是user，跟我们普通账户的账号相同。那密码UserAccountPassword又是什么含义。比如，此时我的UserAccountPassword的值为\n61,62,64,66,6e,68,00,00,00,......\n\n\n\n我光猫背面的密码是\nabdfnh\n\n\n\n此时不难发现,密码字母所对应的ASCII数字，十六进制转换后与UserAccountPassword的值是相同的。\n3.知道这个原理后，我们就可以将密码修改成我们喜欢的密码了。大家自行在查找字符所对应的ASCII数字的十六进制是多少即可，将其替换。\n4.为了方便，我们将普通密码与超级密码设置成相同的，即把TeleAccountPassword所对应的内容替换为UserAccountPassword的内容。\n5.lastgood.xml与backup_lastgood.xml内容基本是相同的，一样替换TeleAccountPassword的内容即可。\n5.4. 生效输入\nreboot\n\n\n\n重启光猫，2分钟后登陆\n192.168.1.1\n\n\n\n输入超级账号\nCMCCAdmin\n\n\n\n自己自定义的密码(比如我刚刚是与普通用户密码设置相同)\nabdfnh\n\n\n\n登陆成功，代表破解成功。\n5.5. 桥接模式网络-宽带设置，然后点击2_INTERNET_R_VID_400,将连接模式从Route改成Brige,保存即可。\n\n6. 注意1.有可能修改成自己自定义密码后，自定义密码不会生效，此时有可能是光猫恢复成了万能密码，也就是\naDm8H%MdA\n\n\n\n可以登录尝试看看。\n2.如果你忘记了自己的宽带密码，拨打人工重置下发的话，光猫也会被移动远程重置信息。此时按照本教程重新再破解一次即可。\n","categories":["生活"],"tags":["闲玩"]},{"title":"Flutter console","url":"/2022/11/01/2022-11-01-Flutter-console/","content":"记录我刚开始初学 Flutter 并使用 IntelliJ IDEA 作为开发的IDE，我想将数据记录到控制台？我试过print()and printDebug()，但我的数据都没有显示在 Flutter 控制台中。\n后面我查看了一些资料知道，如果你在 Flutter 里面Widget，你可以使用debugPrint，例如，\nimport &#x27;package:flutter/foundation.dart&#x27;;debugPrint(&#x27;movieTitle: $movieTitle&#x27;);\n\n或者，使用 Dart 的内置log()函数\nimport &#x27;dart:developer&#x27;;log(&#x27;data: $data&#x27;);\n\n\nDart **print()**函数输出到系统控制台，可以使用 Flutter 日志（基本上是 adb logcat 的包装器）查看它。\n如果一次输出太多，那么 Android 有时会丢弃一些日志。为避免这种情况，可以使用**debugPrint()**。\n在这里找到：https :&#x2F;&#x2F;flutter.io&#x2F;docs&#x2F;testing&#x2F;debugging\n\n","categories":["技术"],"tags":["Flutter"]},{"title":"机试","url":"/2022/11/01/2022-11-01-%E6%9C%BA%E8%AF%95/","content":"不知道可不可以放出来，所以这里就不说明是哪里的题目了，如有侵权，联系我立刻删除（狗头保命）。\n第一题 出租车计费程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。\n比如：\n​\t23再多一块钱就变为25；\n​\t39再多一块钱变为50；\n​\t399再多一块钱变为500；\n小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。给出计费表的表面读数，返回实际产生的费用。\n输入描述:  只有一行，数字N，表示里程表的读数。  (1&lt;=N&lt;=888888888)。输出描述:  一个数字，表示实际产生的费用。以回车结束。    示例1：输入  5输出  4说明  5表示计费表的表面读数。  表示实际产生的费用其实只有4块钱。示例2：输入  17输出  15说明  17表示计费表的表面读数。  15表示实际产生的费用其实只有15块钱。示例3：输入  100输出  81说明：100表示计费表的表面读数，81表示实际产生的费用其实只有81块钱\n\n\n做的时候脑子不会急转弯了。我尝试暴力求解会超时，通过率90%。\n\n第二题 两数之和绝对值最小给定一个随机的整数（可能存在正整数和负整数）数组nums，请你在该数组中找出两个数，其和的绝对值（|nums[x]+nums[y]|）为最小值，并返回这个两个数（按从小到大返回）以及绝对值。\n输入描述:\t一个通过空格分割的有序整数序列，最多1000个整数，且整数数值范围是 [-65535, 65535]。输出描述:\t两数之和和绝对值最小值示例1:输入-1 -3 7 5 11 15输出-3 5 2\n\n\n🐸跳的方式，暴力可以过。\n\n第三题 仿LISP运算LISP语言唯一的语法就是括号要配对。形如 (OP P1 P2 …)，括号内元素由单个空格分割。其中第一个元素OP为操符，后续元素均为其参数，参数个数取决于操作符类型注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 )当前OP类型为add&#x2F;sub&#x2F;mul&#x2F;div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2。\n举例    输入：(mul 3 -7)输出：-21    输入：(add 1 2) 输出：3    输入：(sub (mul 2 4) (div 9 3)) 输出 ：5    输入：(div 1 0) 输出：error\n\n括号匹配思路解决。\n\n题解做的时候没保存到本地，写文章的时候没有地方测试是否100%正确，所以没贴出来。后面有时间上传到 Github 上（先立一个🚩）。\n","categories":["面试"],"tags":["面试机试"]},{"title":"饥荒专用服务器搭建","url":"/2023/02/25/2023-02-25-%E9%A5%A5%E8%8D%92%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","content":"由于种种原因所以尝试去搭建一个饥荒联机（以下简称DST）服务器。\n安装饥荒如果你是Windows就需要安装steam然后下载饥荒。如果你是Linux就需要安装steamCMD然后从steamCMD中\nLinux命令\n$ cd /opt$ sudo mkdir steamcmd &amp;&amp; sudo chown `whoami`:`whoami` steamcmd &amp;&amp; cd steamcmd  # 或者任何你想安装的地方$ wget http://media.steampowered.com/installer/steamcmd_linux.tar.gz$ tar -xvzf steamcmd_linux.tar.gz// 下载服务器本体$ ./steamcmd.sh # 如果你是通过包管理器安装的，直接输入 steam&gt; force_install_dir &lt;你想安装服务器本体的位置&gt;&gt; login anonymous&gt; app_update 343050 validate&gt; quit\n\n\n\n更新饥荒/home/steam/steamCMD/steamcmd.sh +login anonymous +app_update 343050 validate +quitcat /home/steam/Steam/steamapps/common/Don\\&#x27;t\\ Starve\\ Together\\ Dedicated\\ Server/version.txt\n\n启动洞穴cd /home/steam/Steam/steamapps/common/Don\\&#x27;t\\ Starve\\ Together\\ Dedicated\\ Server/bin64 &amp;&amp; ./dontstarve_dedicated_server_nullrenderer_x64 -shard Caves\n\n启动世界cd /home/steam/Steam/steamapps/common/Don\\&#x27;t\\ Starve\\ Together\\ Dedicated\\ Server/bin64 &amp;&amp; ./dontstarve_dedicated_server_nullrenderer_x64\n\n","categories":["游戏"],"tags":["游戏 饥荒"]},{"title":"Hexo Keep主题，如何置顶文章","url":"/2023/03/07/2023-03-07-Hexo-Keep%E4%B8%BB%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/","content":"\n需要主题支持 我用的是：keep\n\n设置置顶，给需要置顶的文章加入sticky参数，如下：\n\n\n  layout: posttitle: Hexo如何置顶文章date: 2023-03-07sticky: 1categories: 技术tags: Hexo\n\n   sticky 是否需要将此文章置顶，不需要置顶的文章可以不写这个属性，Hexo将文章按照sticky的值倒叙排列确定文章置顶的时候顺序，即值越大，越排在前面\n  其他的参数：\n\ntitle 文章标题，在博客页面上展示文章的时候，会把title属性的内容当成文章标题，而不是md文档实际的名称\ndate 文章发布时间\ntags 文章标签\ncategories 文章目录，这个很关键，以上面的内容为例，[java,spring,ioc]表示属于java目录下的spring目录下的ioc，如果当然，在[]中，你也可以只写一个目录名。同时，一篇文章还可以属于多个（多级）目录，[参考Hexo官方文档](Front-matter | Hexo)。\n\n在下面记录一些自己的缺点\n文章写的太散了，以后要整理归档成体系。\n\n","categories":["技术"],"tags":["Hexo"]}]